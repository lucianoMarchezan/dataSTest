<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0"
    xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="sqlmodel"
    nsURI="http:///SQLModel.ecore" nsPrefix="SQLModel">
  <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
    <details key="documentation" value="The class descriptions are copied from SQL99 standard:&#xD;&#xA;Title: (ISO-ANSI Working Draft) Foundation (SQL/Foundation)&#xD;&#xA;Author: Jim Melton (Editor)&#xD;&#xA;References:&#xD;&#xA;1) WG3:ZSH-012 = H2-2002-566 = 5WD-01-Framework-2002-12, WD 9075-1 (SQL/Framework), December, 2002&#xD;&#xA;2) WG3:ZSH-013 = H2-2002-567 = 5WD-02-Foundation-2002-12, WD 9075-2 (SQL/Foundation), December, 2002&#xD;&#xA;3) WG3:ZSH-014 = H2-2002-568 = 5WD-03-CLI-2002-12, WD 9075-3 (SQL/CLI), December, 2002&#xD;&#xA;4) WG3:ZSH-015 = H2-2002-569 = 5WD-04-PSM-2002-12, WD 9075-4 (SQL/PSM), December, 2002&#xD;&#xA;5) WG3:ZSH-016 = H2-2002-570 = 5WD-09-MED-2002-12, WD 9075-9 (SQL/MED), December, 2002&#xD;&#xA;6) WG3:ZSH-017 = H2-2002-571 = 5WD-10-OLB-2002-12, WD 9075-10 (SQL/OLB), December, 2002&#xD;&#xA;7) WG3:ZSH-018 = H2-2002-572 = 5WD-11-Schemata-2002-12, WD 9075-11 (SQL/Schemata), December, 2002&#xD;&#xA;8) WG3:ZSH-019 = H2-2002-573 = 5WD-13-JRT-2002-12, WD 9075-13 (SQL/JRT), December, 2002&#xD;&#xA;9) WG3:ZSH-020 = H2-2002-574 = 5WD-14-XML-2002-12, WD 9075-14 (SQL/XML), December, 2002&#xD;&#xA;"/>
  </eAnnotations>
  <eSubpackages name="schema" nsURI="http:///org/eclipse/datatools/modelbase/sql/schema.ecore"
      nsPrefix="SQLSchema">
    <eClassifiers xsi:type="ecore:EClass" name="IdentitySpecifier" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14.4 Identity columns&#xD;&#xA;&#xD;&#xA;The columns of a base table BT can optionally include not more than one identity column. The declared type of an identity column is either an exact numeric type with scale 0 (zero), INTEGER for example, or a distinct type whose source type is an exact numeric type with scale 0 (zero). An identity column has a start value, an increment, a maximum value, a minimum value, and a cycle option.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;An identity column is associated with an internal sequence generator SG. Let IC be the identity column of BT. When a row R is presented for insertion into BT, if R does not contain a column corresponding to IC, then the value V for IC in the row inserted into BT is obtained by applying the General Rules of Subclause 9.21, &quot;Generation of the next value of a sequence generator&quot;, to SG. The definition of an identity column may specify GENERATED ALWAYS or GENERATED BY DEFAULT.&#xD;&#xA;&#xD;&#xA;NOTE 24: &quot;Start value&quot;, &quot;increment&quot;, &quot;maximum value&quot;, &quot;minimum value&quot;, and &quot;cycle option&quot; are defined in Subclause 4.21, &quot;Sequence generators&quot;.&#xD;&#xA;&#xD;&#xA;NOTE 25: The notion of an internal sequence generator being associated with an identity column is used only for definitional purposes in this International Standard."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="generationType" eType="#//schema/GenerateType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="startValue" eType="ecore:EDataType ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBigInteger"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="increment" eType="ecore:EDataType ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBigInteger"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="minimum" eType="ecore:EDataType ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBigInteger"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="maximum" eType="ecore:EDataType ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBigInteger"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="cycleOption" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="GenerateType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14.4 Identity columns&#xD;&#xA;&#xD;&#xA;The columns of a base table BT can optionally include not more than one identity column. The declared type of an identity column is either an exact numeric type with scale 0 (zero), INTEGER for example, or a distinct type whose source type is an exact numeric type with scale 0 (zero). An identity column has a start value, an increment, a maximum value, a minimum value, and a cycle option.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;An identity column is associated with an internal sequence generator SG. Let IC be the identity column of BT. When a row R is presented for insertion into BT, if R does not contain a column corresponding to IC, then the value V for IC in the row inserted into BT is obtained by applying the General Rules of Subclause 9.21, &quot;Generation of the next value of a sequence generator&quot;, to SG. The definition of an identity column may specify GENERATED ALWAYS or GENERATED BY DEFAULT."/>
      </eAnnotations>
      <eLiterals name="DEFAULT_GENERATED"/>
      <eLiterals name="ALWAYS_GENERATED" value="1"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TypedElement" abstract="true" eSuperTypes="#//schema/SQLObject">
      <eOperations name="setDataType">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Set the type for this TypedElement"/>
        </eAnnotations>
        <eParameters name="newType" eType="#//datatypes/DataType"/>
      </eOperations>
      <eOperations name="getDataType" eType="#//datatypes/DataType">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Get the type for this TypedElement"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="containedType" eType="#//datatypes/SQLDataType"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="referencedType" eType="#//datatypes/UserDefinedType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Dependency" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EReference" name="targetEnd" lowerBound="1"
          eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="dependencyType" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Schema" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.20 SQL-schemas&#xD;&#xA;&#xD;&#xA;An SQL-schema is a persistent descriptor that includes:&#xD;&#xA; - The name of the SQL-schema.&#xD;&#xA; - The &lt;authorization identifier> of the owner of the SQL-schema.&#xD;&#xA; - The name of the default character set for the SQL-schema.&#xD;&#xA; - The &lt;schema path specification> defining the SQL-path for SQL-invoked routines for the SQL-schema.&#xD;&#xA; - The descriptor of every component of the SQL-schema.&#xD;&#xA;&#xD;&#xA;In this part of ISO/IEC 9075, the term &quot;schema&quot; is used only in the sense of SQL-schema. The persistent objects described by the descriptors are said to be owned by or to have been created by the &lt;authorization identifier> of the schema. Each component descriptor is one of:&#xD;&#xA; - A domain descriptor.&#xD;&#xA; - A base table descriptor.&#xD;&#xA; - A view descriptor.&#xD;&#xA; - A constraint descriptor.&#xD;&#xA; - A privilege descriptor.&#xD;&#xA; - A character set descriptor.&#xD;&#xA; - A collation descriptor.&#xD;&#xA; - A transliteration descriptor.&#xD;&#xA; - A user-defined type descriptor.&#xD;&#xA; - A routine descriptor.&#xD;&#xA; - A sequence generator descriptor.&#xD;&#xA;&#xD;&#xA;A schema is created initially using a &lt;schema definition> and may be subsequently modified incrementally over time by the execution of &lt;SQL schema statement> s. &lt;schema name> s are unique within a catalog. A &lt;schema name> is explicitly or implicitly qualified by a &lt;catalog name> that identifies a catalog. Base tables and views are identified by &lt;table name> s. A &lt;table name> consists of a &lt;schema name> and an &lt;identifier> . The &lt;schema name> identifies the schema in which a persistent base table or view identified by the &lt;table name> is defined. Base tables and views defined in different schemas can have &lt;identifier> s that are equal according to the General Rules of Subclause 8.2, &quot;&lt;comparison predicate> &quot;.&#xD;&#xA;&#xD;&#xA;If a reference to a &lt;table name> does not explicitly contain a &lt;schema name> , then a specific &lt;schema name> is implied. The particular &lt;schema name> associated with such a &lt;table name> depends on the context in which the &lt;table name> appears and is governed by the rules for &lt;schema qualified name>. If a reference to an SQL-invoked routine that is contained in a &lt;routine invocation> does not explicitly contain a &lt;schema name> , then the SQL-invoked routine is selected from the SQL-path of the schema. The containing schema of an &lt;SQL schema statement> is defined as the schema identified by the &lt;schema name> implicitly or explicitly contained in the name of the object that is created or manipulated by that SQLstatement. &#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="triggers" upperBound="-1"
          eType="#//tables/Trigger" eOpposite="#//tables/Trigger/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="indices" upperBound="-1"
          eType="#//constraints/Index" eOpposite="#//constraints/Index/Schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="tables" upperBound="-1"
          eType="#//tables/Table" eOpposite="#//tables/Table/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="sequences" upperBound="-1"
          eType="#//schema/Sequence" eOpposite="#//schema/Sequence/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="database" lowerBound="1"
          eType="#//schema/Database" eOpposite="#//schema/Database/schemas"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="assertions" upperBound="-1"
          eType="#//constraints/Assertion" eOpposite="#//constraints/Assertion/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="userDefinedTypes" upperBound="-1"
          eType="#//datatypes/UserDefinedType" eOpposite="#//datatypes/UserDefinedType/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="charSets" upperBound="-1"
          eType="#//datatypes/CharacterSet" eOpposite="#//datatypes/CharacterSet/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="routines" upperBound="-1"
          eType="#//routines/Routine" eOpposite="#//routines/Routine/schema"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="owner" lowerBound="1"
          eType="#//accesscontrol/AuthorizationIdentifier" eOpposite="#//accesscontrol/AuthorizationIdentifier/ownedSchema"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SQLObject" abstract="true" eSuperTypes="../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="The base object to be used for any Relation Database concept, representing the placeholder for the name and alias.  This object will extend ENamedElement in the generated code.  The string attribute name will be inherited&#xD;&#xA;from ENamedElement.&#xD;&#xA;&#xD;&#xA;Note: In the RDB sense, only table and view objects can be represented by aliases, but DB2 defines also database and network aliases, and even for nicknames that refer to data tables or views located on federated systems."/>
      </eAnnotations>
      <eOperations name="addEAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation">
        <eParameters name="source" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eOperations name="addEAnnotationDetail">
        <eParameters name="eAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation"/>
        <eParameters name="key" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
        <eParameters name="value" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eOperations name="getEAnnotationDetail" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eParameters name="eAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation"/>
        <eParameters name="key" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eOperations name="setAnnotationDetail">
        <eParameters name="eAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation"/>
        <eParameters name="key" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
        <eParameters name="value" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eOperations name="removeEAnnotationDetail">
        <eParameters name="eAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation"/>
        <eParameters name="key" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eOperations name="getEAnnotation" eType="ecore:EClass ../../../plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation">
        <eParameters name="source" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="dependencies" upperBound="-1"
          eType="#//schema/Dependency" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="description" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="label" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Sequence" eSuperTypes="#//schema/TypedElement">
      <eStructuralFeatures xsi:type="ecore:EReference" name="identity" lowerBound="1"
          eType="#//schema/IdentitySpecifier" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/sequences"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Database" eSuperTypes="#//schema/SQLObject">
      <eOperations name="getUserDefinedTypes" eType="#//schema/List"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="vendor" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="version" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schemas" upperBound="-1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/database"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="events" upperBound="-1"
          eType="#//schema/Event" eOpposite="#//schema/Event/Database"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="authorizationIds" upperBound="-1"
          eType="#//accesscontrol/AuthorizationIdentifier"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EDataType" name="Date" instanceClassName="java.util.Date"/>
    <eClassifiers xsi:type="ecore:EDataType" name="List" instanceClassName="java.util.List"/>
    <eClassifiers xsi:type="ecore:EEnum" name="ReferentialActionType">
      <eLiterals name="NO_ACTION"/>
      <eLiterals name="RESTRICT" value="1"/>
      <eLiterals name="CASCADE" value="2"/>
      <eLiterals name="SET_NULL" value="3"/>
      <eLiterals name="SET_DEFAULT" value="4"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Event" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="for" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="the type of object on which the event applies"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="condition" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="the condition to be satisfied inorder to activate the event"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="action" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="the action that the event performs after being activated"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="enabled" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="event state"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="Database" lowerBound="1"
          eType="#//schema/Database" eOpposite="#//schema/Database/events"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="constraints" nsURI="http:///org/eclipse/datatools/modelbase/sql/constraints.ecore"
      nsPrefix="SQLConstraints">
    <eClassifiers xsi:type="ecore:EClass" name="Assertion" eSuperTypes="#//constraints/Constraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.17.4 Assertions&#xD;&#xA;&#xD;&#xA;An assertion is a named constraint that may relate to the content of individual rows of a table, to the entire contents of a table, or to a state required to exist among a number of tables. An assertion is described by an assertion descriptor. In addition to the components of every constraint descriptor an assertion descriptor includes:&#xD;&#xA; - The &lt;search condition> .&#xD;&#xA;An assertion is satisfied if and only if the specified &lt;search condition> is not False.&#xD;&#xA;&#xD;&#xA;Syntax defined in section 11.37 &lt;assertion definition>&#xD;&#xA;Function: Specify an integrity constraint.&#xD;&#xA;Format: &lt;assertion definition> ::= CREATE ASSERTION &lt;constraint name> CHECK &lt;left paren> &lt;search condition> &lt;right paren> [ &lt;constraint characteristics> ]&#xD;&#xA;&#xD;&#xA;10.8&#xD;&#xA;2) The &lt;qualified identifier> of &lt;constraint name> shall not be equivalent to the &lt;qualified identifier> of the&#xD;&#xA;&lt;constraint name> of any other constraint defined in the same schema."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="searchCondition" eType="#//expressions/SearchCondition"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/assertions"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constrainedTables" lowerBound="1"
          upperBound="-1" eType="#//tables/BaseTable" derived="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Constraint" abstract="true" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.17 Integrity constraints&#xD;&#xA;&#xD;&#xA;Integrity constraints, generally referred to simply as constraints, define the valid states of SQL-data by constrain-ing the values in the base tables. A constraint is either a table constraint, a domain constraint or an assertion.  A constraint is described by a constraint descriptor. A constraint descriptor is either a table constraint descriptor, a domain constraint descriptor or an assertion descriptor. Every constraint descriptor includes:&#xD;&#xA;  - The name of the constraint.&#xD;&#xA;  - An indication of whether or not the constraint is deferrable.&#xD;&#xA;  - An indication of whether the initial constraint mode is deferred or immediate.&#xD;&#xA;&#xD;&#xA;No integrity constraint shall be defined using a &lt;search condition> that is not retrospectively deterministic.&#xD;&#xA;&#xD;&#xA;The checking of a constraint depends on its constraint mode within the current SQL-transaction. If the constraint mode is immediate, then the constraint is effectively checked at the end of each SQL-statement.  If the constraint mode is deferred, then the constraint is effectively checked when the constraint mode is changed to immediate either explicitly by execution of a &lt;set constraints mode statement> , or implicitly at the end of the current SQL-transaction.&#xD;&#xA;&#xD;&#xA;A table constraint is either a unique constraint, a referential constraint or a table check constraint.&#xD;&#xA;&#xD;&#xA;A domain constraint is a constraint that is specified for a domain. It is applied to all columns that are based on that domain, and to all values cast to that domain.&#xD;&#xA;&#xD;&#xA;An assertion is a named constraint that may relate to the content of individual rows of a table, to the entire contents of a table, or to a state required to exist among a number of tables.&#xD;&#xA;&#xD;&#xA;10.8&#xD;&#xA;2) The &lt;qualified identifier> of &lt;constraint name> shall not be equivalent to the &lt;qualified identifier> of the &lt;constraint name> of any other constraint defined in the same schema.&#xD;&#xA;3) If &lt;constraint check time> is not specified, then INITIALLY IMMEDIATE is implicit.&#xD;&#xA;4) Case:&#xD;&#xA;a) If INITIALLY DEFERRED is specified, then:&#xD;&#xA;  i) NOT DEFERRABLE shall not be specified.&#xD;&#xA;  ii) If DEFERRABLE is not specified, then DEFERRABLE is implicit.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="deferrable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If True allows you to specify when the DBMS should check the constraint for violation (statement end or transaction end).  If False it will always be after statement end.&#xD;&#xA;&#xD;&#xA;Could also be named deferralMode with values DEFERRABLE and NOT DEFERRABLE."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="initiallyDeferred" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="false">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If True isDeferrable must be True and constraint check time will be DEFERRED.  If False constraint check time will be IMMEDIATE.&#xD;&#xA;&#xD;&#xA;Could also be named (initial)ConstraintCheckTime with values INITIALLY DEFERRED and INITIALLY IMMEDIATE.  Default value would be INITIALLY IMMEDIATE.&#xD;&#xA;"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="enforced" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TableConstraint" abstract="true" eSuperTypes="#//constraints/Constraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.17.2 Table constraints&#xD;&#xA;&#xD;&#xA;A table constraint is either a unique constraint, a referential constraint or a table check constraint. A table constraint is described by a table constraint descriptor which is either a unique constraint descriptor, a referential constraint descriptor or a table check constraint descriptor.&#xD;&#xA;&#xD;&#xA;Every table constraint specified for base table T is implicitly a constraint on every subtable of T, by virtue of the fact that every row in a subtable is considered to have a corresponding superrow in every one of its supertables."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="BaseTable" eType="#//tables/BaseTable"
          transient="true" eOpposite="#//tables/BaseTable/constraints"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ReferenceConstraint" abstract="true"
        eSuperTypes="#//constraints/TableConstraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.17.2 Table constraints&#xD;&#xA;&#xD;&#xA;A table constraint is either a unique constraint, a referential constraint or a table check constraint. A table constraint is described by a table constraint descriptor which is either a unique constraint descriptor, a referential constraint descriptor or a table check constraint descriptor.&#xD;&#xA;&#xD;&#xA;A referential constraint is described by a referential constraint descriptor. In addition to the components of every table constraint descriptor, a referential constraint descriptor includes:&#xD;&#xA; - A list of the names of the referencing columns specified in the &lt;referencing columns> .&#xD;&#xA; - The referenced table specified in the &lt;referenced table and columns> .&#xD;&#xA; - A list of the names of the referenced columns specified in the &lt;referenced table and columns> .&#xD;&#xA; - The value of the &lt;match type> , if specified, and the &lt;referential triggered actions> , if specified.&#xD;&#xA;&#xD;&#xA;NOTE 30: If MATCH FULL or MATCH PARTIAL is specified for a referential constraint and if the referencing table has only one column specified in &lt;referential constraint definition> for that referential constraint, or if the referencing table has more than one specified column for that &lt;referential constraint definition> , but none of those columns is nullable, then the effect is the same as if no &lt;match type> were specified.&#xD;&#xA;&#xD;&#xA;The ordering of the lists of referencing column names and referenced column names is implementation-defined, but shall be such that corresponding column names occupy corresponding positions in each list."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="members" lowerBound="1"
          upperBound="-1" eType="#//tables/Column"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CheckConstraint" eSuperTypes="#//constraints/TableConstraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.17.2 Table constraints&#xD;&#xA;&#xD;&#xA;A table constraint is either a unique constraint, a referential constraint or a table check constraint. A table constraint is described by a table constraint descriptor which is either a unique constraint descriptor, a referential constraint descriptor or a table check constraint descriptor.&#xD;&#xA;&#xD;&#xA;A check constraint is satisfied if and only if the specified &lt;search condition> is not False for any or a given row of a table depending on how it was declared.&#xD;&#xA;&#xD;&#xA;A table check constraint is described by a table check constraint descriptor. In addition to the components of every table constraint descriptor, a table check constraint descriptor includes: The &lt;search condition> ."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="searchCondition" eType="#//expressions/SearchCondition"
          containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Section 4.17.2&#xD;&#xA;A check constraint is satisfied if and only if the specified &lt;search condition> is not False for any row of a table."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ForeignKey" eSuperTypes="#//constraints/ReferenceConstraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Section 4.17&#xD;&#xA;In the case that a table constraint is a referential constraint, the table is referred to as the referencing table. The referenced columns of a referential constraint shall be the unique columns of some unique constraint of the&#xD;&#xA;referenced table.&#xD;&#xA;&#xD;&#xA;Section 11.8&#xD;&#xA;5) The referenced table shall be a base table.&#xD;&#xA; Case:&#xD;&#xA;  a) If the referencing table is a persistent base table, then the referenced table shall be a persistent base table.&#xD;&#xA;  b) If the referencing table is a global temporary table, then the referenced table shall be a global temporary table. &#xD;&#xA;  c) If the referencing table is a created local temporary table, then the referenced table shall be either a global temporary table or a created local temporary table.&#xD;&#xA;  d) If the referencing table is a declared local temporary table, then the referenced table shall be either a global temporary table, a created local temporary table or a declared local temporary table.&#xD;&#xA;&#xD;&#xA;6) If the referenced table is a temporary table with ON COMMIT DELETE ROWS specified, then the ref-erencing table shall specify ON COMMIT DELETE ROWS .&#xD;&#xA;7) Each referencing column shall identify a column of the referencing table, and the same column shall not be identified more than once.&#xD;&#xA;9) The &lt;referencing columns> shall contain the same number of &lt;column name> s as the &lt;referenced table and columns> . The i-th column identified in the &lt;referencing columns> corresponds to the i-th column identified in the &lt;referenced table and columns> . The declared type of each referencing column shall be comparable to the declared type of the corresponding referenced column. There shall not be corresponding constituents of the declared type of a referencing column and the declared type of the corresponding referenced column such that one constituent is datetime with time zone and the other is datetime without time zone.&#xD;&#xA;10) If a &lt;referential constraint definition> does not specify any &lt;update rule> , then an &lt;update rule> with a &lt;referential action> of NO ACTION is implicit.&#xD;&#xA;11) If a &lt;referential constraint definition> does not specify any &lt;delete rule> , then a &lt;delete rule> with a &lt;referential action> of NO ACTION is implicit.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="match" eType="#//constraints/MatchType"
          defaultValueLiteral="MATCH_SIMPLE"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="onUpdate" eType="#//schema/ReferentialActionType"
          defaultValueLiteral="NO_ACTION"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="onDelete" eType="#//schema/ReferentialActionType"
          defaultValueLiteral="NO_ACTION"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="uniqueConstraint" eType="#//constraints/UniqueConstraint"
          eOpposite="#//constraints/UniqueConstraint/ForeignKey"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="referencedMembers" lowerBound="1"
          upperBound="-1" eType="#//tables/Column"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="uniqueIndex" eType="#//constraints/Index"
          eOpposite="#//constraints/Index/ForeignKey"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="referencedTable" eType="#//tables/BaseTable"
          eOpposite="#//tables/BaseTable/referencingForeignKeys"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="UniqueConstraint" eSuperTypes="#//constraints/ReferenceConstraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Section 4.17.2&#xD;&#xA;A unique constraint is satisfied if and only if no two rows in a table have the same non-null values in the unique columns.&#xD;&#xA;&#xD;&#xA;Section 11.7&#xD;&#xA;3) If &lt;unique column list> UCL is specified, then&#xD;&#xA;a) Each &lt;column name> in the &lt;unique column list> shall identify a column of T, and the same column&#xD;&#xA;shall not be identified more than once.&#xD;&#xA;b) The set of columns in the &lt;unique column list> shall be distinct from the unique columns of any other unique constraint descriptor that is included in the base table descriptor of T."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ForeignKey" upperBound="-1"
          eType="#//constraints/ForeignKey" eOpposite="#//constraints/ForeignKey/uniqueConstraint"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PrimaryKey" eSuperTypes="#//constraints/UniqueConstraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Section 4.17&#xD;&#xA;A PrimaryKey is a specialization of a UniqueConstraint.  A PrimaryKey additionally requires that none of the values in the specified column or columns be a null value.&#xD;&#xA;&#xD;&#xA;Section 11.7&#xD;&#xA;5) If the &lt;unique specification> specifies PRIMARY KEY , then for each &lt;column name> in the explicit or&#xD;&#xA;implicit &lt;unique column list> for which NOT NULL is not specified, NOT NULL is implicit in the&#xD;&#xA;&lt;column definition> .&#xD;&#xA;6) A &lt;table definition> shall specify at most one implicit or explicit &lt;unique constraint definition> that&#xD;&#xA;specifies PRIMARY KEY ."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="MatchType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="See KeyRelationship description."/>
      </eAnnotations>
      <eLiterals name="MATCH_SIMPLE"/>
      <eLiterals name="MATCH_FULL" value="1"/>
      <eLiterals name="MATCH_PARTIAL" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Index" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EReference" name="Schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/indices"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="clustered" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="false"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="fillFactor" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"
          defaultValueLiteral="0"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="unique" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="false"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="systemGenerated" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="members" lowerBound="1"
          upperBound="-1" eType="#//constraints/IndexMember" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="table" lowerBound="1"
          eType="#//tables/Table" eOpposite="#//tables/Table/index"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ForeignKey" upperBound="-1"
          eType="#//constraints/ForeignKey" eOpposite="#//constraints/ForeignKey/uniqueIndex"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="includedMembers" upperBound="-1"
          eType="#//constraints/IndexMember" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="IndexMember" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="IndexMember is an EObject.  It does not have a name or associated SQL descriptor so it is not an SQLObject.  This is the way we have chosen to model Index columns because EMF does not support association classes."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="incrementType" eType="#//constraints/IncrementType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="column" lowerBound="1"
          eType="#//tables/Column"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="IncrementType">
      <eLiterals name="ASC"/>
      <eLiterals name="DESC" value="1"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="datatypes" nsURI="http:///org/eclipse/datatools/modelbase/sql/datatypes.ecore"
      nsPrefix="SQLDataTypes">
    <eClassifiers xsi:type="ecore:EClass" name="UserDefinedType" abstract="true" eSuperTypes="#//datatypes/DataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.7 User-defined types&#xD;&#xA;&#xD;&#xA;A user-defined type is a schema object, identified by a &lt;user-defined type name> . The definition of a userdefined type specifies a number of components, including in particular a list of attribute definitions. Although the attribute definitions are said to define the representation of the user-defined type, in fact they implicitly define certain functions (observers and mutators) that are part of the interface of the user-defined type; physical representations of user-defined type values are implementation-dependent.&#xD;&#xA;&#xD;&#xA;The representation of a user-defined type is expressed either as a single data type (some predefined data type, called the source type), in which case the user-defined type is said to be a distinct type, or as a list of attribute definitions, in which case it is said to be a structured type.&#xD;&#xA;&#xD;&#xA;A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:&#xD;&#xA; - The name of the user-defined type (&lt;user-defined type name> ). This is the type designator of that type, used in type precedence lists (see Subclause 9.5, &quot;Type precedence list determination&quot;).&#xD;&#xA; - An indication of whether the user-defined type is a structured type or a distinct type.&#xD;&#xA; - The ordering form for the user-defined type (EQUALS , FULL , or NONE ).&#xD;&#xA; - The ordering category for the user-defined type (RELATIVE , MAP , or STATE ).&#xD;&#xA; - A &lt;specific routine designator> identifying the ordering function, depending on the ordering category.&#xD;&#xA; - If the user-defined type is a direct subtype of another user-defined type, then the name of that user-defined type.&#xD;&#xA; - If the representation is a predefined data type, then the descriptor of that type; otherwise the attribute descriptor of every originally-defined attribute and every inherited attribute of the user-defined type.&#xD;&#xA; - An indication of whether the user-defined type is instantiable or not instantiable.&#xD;&#xA; - An indication of whether the user-defined type is final or not final.&#xD;&#xA; - The transform descriptor of the user-defined type.&#xD;&#xA; - If the user-defined type is a structured type, then:&#xD;&#xA; - Whether the referencing type of the structured type has a user-defined representation, a derived representation, or a system-defined representation.&#xD;&#xA; - If user-defined representation is specified, then the type descriptor of the representation type of the referencing type of the structured type; otherwise, if derived representation is specified, then the list of attributes.&#xD;&#xA;NOTE 15 - &quot;user-defined representation&quot;, &quot;derived representation&quot;, and &quot;system-defined representation&quot; of a reference type are defined in Subclause 4.9, &quot;Reference types&quot;.&#xD;&#xA; - If the &lt;method specification list> is specified, then for each &lt;method specification> contained in &lt;method specification list> , a method specification descriptor that includes:&#xD;&#xA; - The &lt;method name>.&#xD;&#xA; - The &lt;specific method name>.&#xD;&#xA; - The &lt;SQL parameter declaration list> augmented to include the implicit first parameter with parameter name SELF.&#xD;&#xA; - The &lt;language name>.&#xD;&#xA; - If the &lt;language name> is not SQL, then the &lt;parameter style>.&#xD;&#xA; - The &lt;returns data type>.&#xD;&#xA; - The &lt;result cast from type> , if any.&#xD;&#xA; - An indication as to whether the &lt;method specification> is an &lt;original method specification> or an &lt;overriding method specification> .&#xD;&#xA; - If the &lt;method specification> is an &lt;original method specification> , then an indication of whether STATIC or CONSTRUCTOR is specified.&#xD;&#xA; - An indication whether the method is deterministic.&#xD;&#xA; - An indication whether the method possibly writes SQL data, possibly reads SQL data, possibly contains SQL, or does not possibly contain SQL.&#xD;&#xA; - An indication whether the method should not be invoked if any argument is the null value, in which case the value of the method is the null value.&#xD;&#xA;NOTE 16 - The characteristics of an &lt;overriding method specification> other than the &lt;method name> , &lt;SQL parameter declaration list> , and &lt;returns data type> are the same as the characteristics for the corresponding &lt;original method specification> .&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/userDefinedTypes"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ordering" eType="#//datatypes/UserDefinedTypeOrdering"
          containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DataType" abstract="true" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. Exactly one of the data types of a value V, namely the most specific type of V, is a subtype of every data type of V. A &lt;value expression> E has exactly one declared type, common to every possible result of evaluating E. Items that can be referenced by name, such as SQL parameters, columns, fields, attributes, and variables, also have declared types.&#xD;&#xA;&#xD;&#xA;SQL supports three sorts of data types: predefined data types, constructed types, and user-defined types. Predefined data types are sometimes called 'built-in data types', though not in this International Standard. Userdefined types can be defined by a standard, by an implementation, or by an application. A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;&#xD;&#xA;Every predefined data type is a subtype of itself and of no other data types. It follows that every predefined data type is a supertype of itself and of no other data types. The predefined data types are individually described in each of Subclause 4.2, &quot;Character strings&quot;, through Subclause 4.6, &quot;Datetimes and intervals&quot;. Row types, reference types and collection types are described in Subclause 4.8, &quot;Row types&quot;, Subclause 4.9, &quot;Reference types&quot;, Subclause 4.10, &quot;Collection types&quot;, respectively.&#xD;&#xA;&#xD;&#xA;SQL defines predefined data types named by the following &lt;key word> s: CHARACTER , CHARACTER VARYING , CHARACTER LARGE OBJECT , BINARY LARGE OBJECT , NUMERIC , DECIMAL , SMALLINT , INTEGER , BIGINT , FLOAT , REAL , DOUBLE PRECISION , BOOLEAN , DATE , TIME , TIMESTAMP , and INTERVAL . These names are used in the type designators that constitute the type precedence lists specified in Subclause 9.5, &quot;Type precedence list determination&quot;.&#xD;&#xA;&#xD;&#xA;For reference purposes:&#xD;&#xA; - The data types CHARACTER , CHARACTER VARYING , and CHARACTER LARGE OBJECT are collectively referred to as character string types.&#xD;&#xA; - The data type BINARY LARGE OBJECT is referred to as the binary string type and the values of binary string types are referred to as binary strings.&#xD;&#xA; - The data types CHARACTER LARGE OBJECT and BINARY LARGE OBJECT are collectively referred to as large object string types and the values of large object string types are referred to as large object strings.&#xD;&#xA; - Character string types and binary string types are collectively referred to as string types and values of string types are referred to as strings.&#xD;&#xA; - The data types NUMERIC , DECIMAL , SMALLINT , INTEGER , and BIGINT are collectively referred to as exact numeric types.&#xD;&#xA; - The data types FLOAT , REAL , and DOUBLE PRECISION are collectively referred to as approximate numeric types.&#xD;&#xA; - Exact numeric types and approximate numeric types are collectively referred to as numeric types. Values of numeric types are referred to as numbers.&#xD;&#xA; - The data types TIME WITHOUT TIME ZONE and TIME WITH TIME ZONE are collectively referred to as time types (or, for emphasis, as time with or without time zone).&#xD;&#xA; - The data types TIMESTAMP WITHOUT TIME ZONE and TIMESTAMP WITH TIME ZONE are collectively referred to as timestamp types (or, for emphasis, as timestamp with or without time zone).&#xD;&#xA; - The data types DATE , TIME , and TIMESTAMP are collectively referred to as datetime types.&#xD;&#xA; - Values of datetime types are referred to as datetimes.&#xD;&#xA; - The data type INTERVAL is referred to as an interval type. Values of interval types are called intervals.&#xD;&#xA;&#xD;&#xA;Each data type has an associated data type descriptor; the contents of a data type descriptor are determined by the specific data type that it describes. A data type descriptor includes an identification of the data type and all information needed to characterize a value of that data type. Subclause 6.1, &quot;&lt;data type> &quot;, describes the semantic properties of each data type.&#xD;&#xA;&#xD;&#xA;A structured type ST is directly based on a data type DT if any of the following are true:&#xD;&#xA; - DT is the declared type of some attribute of ST.&#xD;&#xA; - DT is a direct supertype of ST.&#xD;&#xA; - DT is a direct subtype of ST.&#xD;&#xA; - DT is compatible with ST.&#xD;&#xA;&#xD;&#xA;A collection type CT is directly based on a data type DT if DT is the element type of CT.&#xD;&#xA;A row type RT is directly based on a data type DT if DT is the declared type of some field (or the data type of the domain of some field) whose descriptor is included in the descriptor of RT.&#xD;&#xA;A data type DT1 is based on a data type DT2 if DT1 is directly based on DT2 or DT1 is directly based on some data type that is based on DT2.&#xD;&#xA;&#xD;&#xA;A type TY is usage-dependent on a user-defined type UDT if one of the following conditions is true:&#xD;&#xA; - TY is UDT.&#xD;&#xA; - TY is a reference type whose referenced type is UDT.&#xD;&#xA; - TY is a row type, and the declared type of a field of TY is usage-dependent on UDT.&#xD;&#xA; - TY is a collection type, and the declared element type of TY is usage-dependent on UDT.&#xD;&#xA;&#xD;&#xA;Each host language has its own data types, which are separate and distinct from SQL data types, even though similar names may be used to describe the data types. Mappings of SQL data types to data types in host languages are described in Subclause 11.50, &quot;&lt;SQL-invoked routine> &quot;, and Subclause 20.1, &quot;&lt;embedded SQL host program> &quot;. Not every SQL data type has a corresponding data type in every host language. Ordering and comparison of values of the predefined data types requires knowledge only about those predefined data types. However, to be able to compare and order values of constructed types or of user-defined types, additional information is required. We say that some type T is S-ordered, for some set of types S, if, in order to compare and order values of type T, information about ordering at least one of the types in S is first required.&#xD;&#xA;&#xD;&#xA;A definition of S-ordered is required for several S (that is, for several sets of types), but not for all possible such sets.&#xD;&#xA;The general definition of S-ordered is this:&#xD;&#xA;Let T be a type and let S be a set of types. T is S-ordered if one of the following is true:&#xD;&#xA;- T is a member of S.&#xD;&#xA;- T is a row type and the declared type of some field of T is S-ordered.&#xD;&#xA;- T is a collection type and the element type of T is S-ordered.&#xD;&#xA;- T is a structured type whose comparison form is STATE and the declared type of some attribute of T is S-ordered.&#xD;&#xA;- T is a user-defined type whose comparison form is MAP and the return type of the SQL-invoked function that is identified by the &lt;map function specification> is S-ordered.&#xD;&#xA;- T is a reference type with a derived representation and the declared type of some attribute enumerated by the &lt;derived representation> is S-ordered.&#xD;&#xA;&#xD;&#xA;The notion of S-ordered is applied in the following definitions:&#xD;&#xA;- A type T is LOB-ordered if T is L-ordered, where L is the set of large object types.&#xD;&#xA;- A type T is array-ordered if T is ARR-ordered, where ARR is the set of array types.&#xD;&#xA;- A type T is multiset-ordered if T is MUL-ordered, where MUL is the set of multiset types.&#xD;&#xA;- A type T is reference-ordered if T is REF-ordered, where REF is the set of reference types.&#xD;&#xA;- A type T is DT-EC-ordered if T is DTE-ordered, where DTE is the set of distinct types with EQUALS ONLY comparison form (DT-EC stands for &quot;distinct type-equality comparison&quot;).&#xD;&#xA;- A type T is DT-FC-ordered if T is DTF-ordered, where DTF is the set of distinct types with FULL comparison form.&#xD;&#xA;- A type T is DT-NC-ordered if T is DTN-ordered, where DTN is the set of distinct types with no comparison form.&#xD;&#xA;- A type T is ST-EC-ordered if T is STE-ordered, where STE is the set of structured types with EQUALS ONLY comparison form.&#xD;&#xA;- A type T is ST-FC-ordered if T is STF-ordered, where STF is the set of structured types with FULL comparison form.&#xD;&#xA;- A type T is ST-NC-ordered if T is STN-ordered, where STN is the set of structured types with no comparison form.&#xD;&#xA;- A type T is ST-ordered if T is ST-EC-ordered, ST-FC-ordered or ST-NC-ordered.&#xD;&#xA;- A type T is UDT-EC-ordered if T is either DT-EC-ordered or ST-EC-ordered (UDT stands for &quot;user-defined type&quot;).&#xD;&#xA;- A type T is UDT-FC-ordered if T is either DT-FC-ordered or ST-FC-ordered&#xD;&#xA;- A type T is UDT-NC-ordered if T is either DT-NC-ordered or ST-NC-ordered.&#xD;&#xA;&#xD;&#xA;The notion of constituent of a declared type DT is defined recursively as follows:&#xD;&#xA;- DT is a constituent of DT.&#xD;&#xA;- If DT is a row type, then the declared type of each field of DT is a constituent of DT.&#xD;&#xA;- If DT is a collection type, then the element type of DT is a constituent of DT.&#xD;&#xA;- Every constituent of a constituent of DT is a constituent of DT.&#xD;&#xA;&#xD;&#xA;Two data types, T1 and T2, are said to be compatible if T1 is assignable to T2, T2 is assignable to T1, and their descriptors include the same data type name. If they are row types, it shall further be the case that the declared types of their corresponding fields are pairwise compatible. If they are collection types, it shall further be the case that their element types are compatible. If they are reference types, it shall further be the case that their referenced types are compatible.&#xD;&#xA;NOTE 8 - The data types &quot;CHARACTER (n) CHARACTER SET CS1&quot; and &quot;CHARACTER (m) CHARACTER SET CS2&quot;, where CS1 1 CS2, have descriptors that include the same data type name (CHARACTER ), but are not mutually assignable; therefore, they are not compatible.&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="setContainer">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="This method is used to set the type on the given Column.  It is implemented on the child classes of DataType.  The concrete children classses will know which type relationship to use on Column to set the data type."/>
        </eAnnotations>
        <eParameters name="newContainer" eType="#//schema/TypedElement"/>
      </eOperations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PredefinedDataType" abstract="true"
        eSuperTypes="#//datatypes/SQLDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;Every predefined data type is a subtype of itself and of no other data types. It follows that every predefined data type is a supertype of itself and of no other data types. The predefined data types are individually described in each of Subclause 4.2, &quot;Character strings&quot;, through Subclause 4.6, &quot;Datetimes and intervals&quot;. Row types, reference types and collection types are described in Subclause 4.8, &quot;Row types&quot;, Subclause 4.9, &quot;Reference types&quot;, Subclause 4.10, &quot;Collection types&quot;, respectively.&#xD;&#xA;&#xD;&#xA;SQL defines predefined data types named by the following &lt;key word> s: CHARACTER , CHARACTER VARYING , CHARACTER LARGE OBJECT , BINARY LARGE OBJECT , NUMERIC , DECIMAL , SMALLINT , INTEGER , BIGINT , FLOAT , REAL , DOUBLE PRECISION , BOOLEAN , DATE , TIME , TIMESTAMP , and INTERVAL . These names are used in the type designators that constitute the type precedence lists specified in Subclause 9.5, &quot;Type precedence list determination&quot;."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="primitiveType" eType="#//datatypes/PrimitiveType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CollectionDataType" abstract="true"
        eSuperTypes="#//datatypes/ConstructedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="element" lowerBound="1"
          upperBound="-1" eType="#//datatypes/DataType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="NumericalDataType" abstract="true"
        eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.4 Numbers&#xD;&#xA;&#xD;&#xA;A number is either an exact numeric value or an approximate numeric value. Any two numbers are comparable.&#xD;&#xA;A numeric type is described by a numeric type descriptor. A numeric type descriptor contains:&#xD;&#xA; - The name of the specific numeric type (NUMERIC , DECIMAL , SMALLINT , INTEGER , BIGINT , FLOAT , REAL , or DOUBLE PRECISION).&#xD;&#xA; - The precision of the numeric type.&#xD;&#xA; - The scale of the numeric type, if it is an exact numeric type.&#xD;&#xA; - An indication of whether the precision (and scale) are expressed in decimal or binary terms.&#xD;&#xA;&#xD;&#xA;An SQL-implementation is permitted to regard certain &lt;exact numeric type> s as equivalent, if they have the same precision, scale, and radix, as permitted by the Syntax Rules of Subclause 6.1, &quot;&lt;data type> &quot;. When two or more &lt;exact numeric type> s are equivalent, the SQL-implementation chooses one of these equivalent &lt;exact numeric type> s as the normal form representing that equivalence class of &lt;exact numeric type> s. The normal form determines the name of the exact numeric type in the numeric type descriptor.&#xD;&#xA;&#xD;&#xA;Similarly, an SQL-implementation is permitted to regard certain &lt;approximate numeric type> s as equivalent, as permitted the Syntax Rules of Subclause 6.1, &quot;&lt;data type> &quot;, in which case the SQL-implementation chooses a normal form to represent each equivalence class of &lt;approximate numeric type> and the normal form determines the name of the approximate numeric type.&#xD;&#xA;&#xD;&#xA;For every numeric type, the least value is less than zero and the greatest value is greater than zero.&#xD;&#xA;&#xD;&#xA;4.4.1 Characteristics of numbers&#xD;&#xA;&#xD;&#xA;An exact numeric type has a precision P and a scale S. P is a positive integer that determines the number of significant digits in a particular radix R, where R is either 2 or 10. S is a non-negative integer. Every value of an exact numeric type of scale S is of the form n x 10-S, where n is an integer such that -RP &lt;= n &lt; RP.&#xD;&#xA;NOTE 13 - Not every value in that range is necessarily a value of the type in question.&#xD;&#xA;&#xD;&#xA;An approximate numeric value consists of a mantissa and an exponent. The mantissa is a signed numeric value, and the exponent is a signed integer that specifies the magnitude of the mantissa. An approximate numeric value has a precision. The precision is a positive integer that specifies the number of significant binary digits in the mantissa. The value of an approximate numeric value is the mantissa multiplied by a factor determined by the exponent.&#xD;&#xA;&#xD;&#xA;An &lt;approximate numeric literal> ANL consists of an &lt;exact numeric literal> (called the &lt;mantissa> ), the letter 'E' or 'e', and a &lt;signed integer> (called the &lt;exponent> ). If M is the value of the &lt;mantissa> and E is the value of the &lt;exponent> , then M * 10E is the apparent value of ANL. The actual value of ANL is approximately the apparent value of ANL, according to implementation-defined rules.&#xD;&#xA;&#xD;&#xA;A number is assignable only to sites of numeric type. If an assignment of some number would result in a loss of its most significant digit, an exception condition is raised. If least significant digits are lost, implementationdefined rounding or truncating occurs, with no exception condition being raised. The rules for arithmetic are specified in Subclause 6.26, &quot;&lt;numeric value expression> &quot;.&#xD;&#xA;&#xD;&#xA;Whenever an exact or approximate numeric value is assigned to an exact numeric value site, an approximation of its value that preserves leading significant digits after rounding or truncating is represented in the declared type of the target. The value is converted to have the precision and scale of the target. The choice of whether to truncate or round is implementation-defined.&#xD;&#xA;&#xD;&#xA;An approximation obtained by truncation of a numeric value N for an &lt;exact numeric type> T is a value V in T such that N is not closer to zero than is V and there is no value in T between V and N. An approximation obtained by rounding of a numeric value N for an &lt;exact numeric type> T is a value V in T such that the absolute value of the difference between N and the numeric value of V is not greater than half the absolute value of the difference between two successive numeric values in T. If there is more than one such value V, then it is implementation-defined which one is taken.&#xD;&#xA;&#xD;&#xA;All numeric values between the smallest and the largest value, inclusive, in a given exact numeric type have an approximation obtained by rounding or truncation for that type; it is implementation-defined which other numeric values have such approximations. An approximation obtained by truncation or rounding of a numeric value N for an &lt;approximate numeric type> T is a value V in T such that there is no numeric value in T and distinct from that of V that lies between the numeric value of V and N, inclusive.&#xD;&#xA;&#xD;&#xA;If there is more than one such value V then it is implementation-defined which one is taken. It is implementationdefined which numeric values have approximations obtained by rounding or truncation for a given approximate numeric type. Whenever an exact or approximate numeric value is assigned to an approximate numeric value site, an approximation of its value is represented in the declared type of the target. The value is converted to have the precision of the target.&#xD;&#xA;&#xD;&#xA;Operations on numbers are performed according to the normal rules of arithmetic, within implementationdefined limits, except as provided for in Subclause 6.26, &quot;&lt;numeric value expression> &quot;.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="precision" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CharacterStringDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;For reference purposes:&#xD;&#xA; - The data types CHARACTER , CHARACTER VARYING , and CHARACTER LARGE OBJECT are collectively referred to as character string types.&#xD;&#xA; - The data type BINARY LARGE OBJECT is referred to as the binary string type and the values of binary string types are referred to as binary strings.&#xD;&#xA; - The data types CHARACTER LARGE OBJECT and BINARY LARGE OBJECT are collectively referred to as large object string types and the values of large object string types are referred to as large object strings.&#xD;&#xA; - Character string types and binary string types are collectively referred to as string types and values of string types are referred to as strings.&#xD;&#xA;&#xD;&#xA;4.2 Character strings&#xD;&#xA;&#xD;&#xA;A character string is a sequence of characters. All the characters in a character string are taken from a single character set. A character string has a length, which is the number of characters in the sequence. The length is 0 (zero) or a positive integer. A character string type is described by a character string type descriptor.&#xD;&#xA;&#xD;&#xA;A character string type descriptor contains:&#xD;&#xA; - The name of the specific character string type (CHARACTER , CHARACTER VARYING , and CHARACTER LARGE OBJECT ; NATIONAL CHARACTER , NATIONAL CHARACTER VARYING , and NATIONAL CHARACTER LARGE OBJECT are represented as CHARACTER , CHARACTER VARYING , and CHARACTER LARGE OBJECT , respectively).&#xD;&#xA; - The length or maximum length in characters of the character string type.&#xD;&#xA; - The catalog name, schema name, and character set name of the character set of the character string type.&#xD;&#xA; - The catalog name, schema name, and collation name of the collation of the character string type.&#xD;&#xA;&#xD;&#xA;The character set of a character string type may be specified explicitly or implicitly.&#xD;&#xA;&#xD;&#xA;The &lt;key word>s NATIONAL CHARACTER are used to specify an implementation-defined character set. Special syntax (N'string') is provided for representing literals in that character set. With two exceptions, a character string expression is assignable only to sites of a character string type whose character set is the same. The exceptions are as specified in Subclause 4.2.7, &quot;Universal character sets&quot;, and such other cases as may be implementation-defined. If a store assignment would result in the loss of non-&lt;space> characters due to truncation, then an exception condition is raised. If a retrieval assignment or evaluation of a &lt;cast specification> would result in the loss of characters due to truncation, then a warning condition is raised.&#xD;&#xA;&#xD;&#xA;Character sets fall into three categories: those defined by national or international standards, those defined by SQL-implementations, and those defined by applications. The character sets defined by ISO/IEC 10646 and The Unicode Standard are known as Universal Character Sets (UCS) and their treatment is described in Subclause 4.2.7, &quot;Universal character sets&quot;. Every character set contains the &lt;space> character (equivalent to U+0020). An application defines a character set by assigning a new name to a character set from one of the first two categories. They can be defined to &quot;reside&quot; in any schema chosen by the application. Character sets defined by standards or by SQL-implementations reside in the Information Schema (named INFORMATION_SCHEMA) in each catalog, as do collations defined by standards and collations, transliterations, and transcodings defined by SQL-implementations.&#xD;&#xA;&#xD;&#xA;NOTE 9 : The Information Schema is defined in ISO/IEC 9075-11.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="length" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"
          defaultValueLiteral="1"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="coercibility" eType="#//datatypes/CoercibilityType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="fixedLength" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          changeable="false" derived="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="collationName" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="characterSet" lowerBound="1"
          eType="#//datatypes/CharacterSet"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="RowDataType" eSuperTypes="#//datatypes/ConstructedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="fields" lowerBound="1"
          upperBound="-1" eType="#//datatypes/Field" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ArrayDataType" abstract="true" eSuperTypes="#//datatypes/CollectionDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="maxCardinality" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="MultisetDataType" abstract="true"
        eSuperTypes="#//datatypes/CollectionDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BooleanDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.5 Boolean types&#xD;&#xA;&#xD;&#xA;The data type boolean comprises the distinct truth values True and False. Unless prohibited by a NOT NULL constraint, the boolean data type also supports the Unknown truth value as the null value. This specification does not make a distinction between the null value of the boolean data type and the Unknown truth value that is the result of an SQL &lt;predicate> , &lt;search condition> , or &lt;boolean value expression> ; they may be used interchangeably to mean exactly the same thing.&#xD;&#xA;&#xD;&#xA;The boolean data type is described by the boolean data type descriptor. The boolean data type descriptor contains:&#xD;&#xA; - The name of the boolean data type (BOOLEAN )."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="IntervalDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.6 Datetimes and intervals&#xD;&#xA;&#xD;&#xA;An interval data type is described by an interval data type descriptor.&#xD;&#xA;&#xD;&#xA;An interval data type descriptor contains:&#xD;&#xA; - The name of the interval data type (INTERVAL ).&#xD;&#xA; - An indication of whether the interval data type is a year-month interval or a day-time interval.&#xD;&#xA; - The &lt;interval qualifier> that describes the precision of the interval data type.&#xD;&#xA;&#xD;&#xA;A value described by an interval data type descriptor is always signed. Every datetime or interval data type has an implied length in positions. Let D denote a value in some datetime or interval data type DT. The length in positions of DT is constant for all D. The length in positions is the number of characters from the character set SQL_TEXT that it would take to represent any value in a given datetime or interval data type.&#xD;&#xA;&#xD;&#xA;An approximation obtained by rounding of a datetime or interval value D for a &lt;datetime type> or &lt;interval type> T is a value V in T such that the absolute value of the difference between D and the numeric value of V is not greater than half the absolute value of the difference between two successive datetime or interval values in T. If there is more than one such value V, then it is implementation-defined which one is taken.&#xD;&#xA;&#xD;&#xA;4.6.2 Intervals&#xD;&#xA;&#xD;&#xA;There are two classes of intervals. One class, called year-month intervals, has an express or implied datetime precision that includes no fields other than YEAR and MONTH , though not both are required. The other class, called day-time intervals, has an express or implied interval precision that can include any fields other than YEAR or MONTH .&#xD;&#xA;&#xD;&#xA;The actual subset of fields that comprise a value of either type of interval is defined by an &lt;interval qualifier> and this subset is known as the precision of the value. Within a value of type interval, the first field is constrained only by the &lt;interval leading field precision> of the associated &lt;interval qualifier> . Table 6, &quot;Valid values for fields in INTERVAL values&quot;, specifies the constraints on subsequent field values.&#xD;&#xA;&#xD;&#xA;Values in interval fields other than SECOND are integers and have precision 2 when not the first field. SECOND, however, can be defined to have an &lt;interval fractional seconds precision> that indicates the number of decimal digits maintained following the decimal point in the seconds value. When not the first field, SECOND has a precision of 2 places before the decimal point.&#xD;&#xA;&#xD;&#xA;Fields comprising an item of type interval are also constrained by the definition of the Gregorian calendar. Year-month intervals are comparable only with other year-month intervals. If two year-month intervals have different interval precisions, they are, for the purpose of any operations between them, effectively converted to the same precision by appending new &lt;primary datetime field> s to either the most significant end of one interval, the least significant end of one interval, or both. New least significant &lt;primary datetime field> s are assigned a value of 0 (zero). When it is necessary to add new most significant datetime fields, the associated value is effectively converted to the new precision in a manner obeying the natural rules for dates and times associated with the Gregorian calendar.&#xD;&#xA;&#xD;&#xA;Day-time intervals are comparable only with other day-time intervals. If two day-time intervals have different interval precisions, they are, for the purpose of any operations between them, effectively converted to the same precision by appending new &lt;primary datetime field> s to either the most significant end of one interval or the least significant end of one interval, or both. New least significant &lt;primary datetime field> s are assigned a value of 0 (zero). When it is necessary to add new most significant datetime fields, the associated value is effectively converted to the new precision in a manner obeying the natural rules for dates and times associated with the Gregorian calendar.&#xD;&#xA;&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="leadingQualifier" eType="#//datatypes/IntervalQualifierType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="trailingQualifier" eType="#//datatypes/IntervalQualifierType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="leadingFieldPrecision"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="trailingFieldPrecision"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="fractionalSecondsPrecision"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BinaryStringDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.3 Binary strings&#xD;&#xA;&#xD;&#xA;A binary string is a sequence of octets that does not have either a character set or collation associated with it. A binary string data type is described by a binary string data type descriptor. A binary string data type descriptor contains:&#xD;&#xA; - The name of the data type (BINARY LARGE OBJECT ).&#xD;&#xA; - The maximum length of the binary string data type (in octets).&#xD;&#xA;&#xD;&#xA;A binary string is assignable only to sites of data type BINARY LARGE OBJECT . If a store assignment would result in the loss of non-zero octets due to truncation, then an exception condition is raised. If a retrieval assignment would result in the loss of octets due to truncation, then a warning condition is raised."/>
      </eAnnotations>
      <eOperations name="equals" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="length" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CharacterSet" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.2.6 Character sets&#xD;&#xA;&#xD;&#xA;An SQL &lt;character set specification> allows a reference to a character set name defined by a standard, an SQLimplementation,&#xD;&#xA;or a user. A character set is described by a character set descriptor. A character set descriptor includes:&#xD;&#xA; - The name of the character set.&#xD;&#xA; - The name of the character repertoire for the character set.&#xD;&#xA; - The name of the character encoding form for the character set.&#xD;&#xA; - The name of the default collation for the character set.&#xD;&#xA;&#xD;&#xA;The following SQL supported character set names are specified as part of ISO/IEC 9075:&#xD;&#xA; - SQL_CHARACTER is a character set whose repertoire is SQL_CHARACTER and whose character encoding form is SQL_CHARACTER. The name of its default collation is SQL_CHARACTER.&#xD;&#xA; - GRAPHIC_IRV is a character set whose repertoire is GRAPHIC_IRV and whose character encoding form is GRAPHIC_IRV. The name of its default collation is GRAPHIC_IRV.&#xD;&#xA; - ASCII_GRAPHIC is a synonym for GRAPHIC_IRV.&#xD;&#xA; - LATIN1 is a character set whose repertoire is LATIN1 and whose character encoding form is LATIN1. The name of its default collation is LATIN1.&#xD;&#xA; - ISO8BIT is a character set whose repertoire is ISO8BIT and whose character encoding form is ISO8BIT. The name of its default collation is ISO8BIT.&#xD;&#xA; - ASCII_FULL is a synonym for ISO8BIT.&#xD;&#xA; - UTF32 is a character set whose repertoire is UCS and whose character encoding form is UTF32. It is implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.&#xD;&#xA; - UTF16 is a character set whose repertoire is UCS and whose character encoding form is UTF16. It is implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.&#xD;&#xA; - UTF8 is the name of a character set whose repertoire is UCS and whose character encoding form is UTF8. It is implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.&#xD;&#xA; - SQL_TEXT is a character set whose repertoire is SQL_TEXT and whose character encoding form is SQL_TEXT. The name of its default collation is SQL_TEXT.&#xD;&#xA; - SQL_IDENTIFIER is a character set whose repertoire is SQL_IDENTIFIER and whose character encoding form is SQL_IDENTIFIER. The name of its default collation is SQL_IDENTIFIER.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;4.2.7 Universal character sets&#xD;&#xA;&#xD;&#xA;A UCS string is a character string whose character repertoire is UCS and whose character encoding form is one of UTF8, UTF16, or UTF32. Any two UCS strings are comparable.&#xD;&#xA;An SQL-implementation may assume that all UCS strings are normalized in Normalization Form C (NFC), as specified by [Unicode15]. With the exception of &lt;normalize function> and &lt;normalized predicate> , the result of any operation on an unnormalized UCS string is implementation-defined.&#xD;&#xA;&#xD;&#xA;Conversion of UCS strings from one character set to another is automatic. Detection of a noncharacter in a UCS-string causes an exception condition to be raised. The detection of an unassigned code point does not."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="repertoire" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="defaultCollation" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="encoding" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/charSets"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="CoercibilityType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.2.1 Comparison of character strings&#xD;&#xA;&#xD;&#xA;Two character strings are comparable if and only if either they have the same character set or there exists at least one collation that is applicable to both their respective character sets.&#xD;&#xA;&#xD;&#xA;A collation is defined by ISO/IEC 14651 as &quot;a process by which two strings are determined to be in exactly one of the relationships of less than, greater than, or equal to one another&quot;. Each collation known in an SQLenvironment is applicable to one or more character sets, and for each character set, one or more collations are applicable to it, one of which is associated with it as its character set collation.&#xD;&#xA;&#xD;&#xA;Anything that has a declared type can, if that type is a character string type, be associated with a collation applicable to its character set; this is known as a declared type collation. Every declared type that is a character string type has a collation derivation, this being either none, implicit, or explicit. The collation derivation of a declared type with a declared type collation that is explicitly or implicitly specified by a &lt;data type> is implicit. If the collation derivation of a declared type that has a declared type collation is not implicit, then it is explicit. The collation derivation of an expression of character string type that has no declared type collation is none.&#xD;&#xA;&#xD;&#xA;An operation that explicitly or implicitly involves character string comparison is a character comparison operation. At least one of the operands of a character comparison operation shall have a declared type collation. There may be an SQL-session collation for some or all of the character sets known to the SQL-implementation (see Subclause 4.37, &quot;SQL-sessions&quot;).&#xD;&#xA;&#xD;&#xA;The collation used for a particular character comparison is specified by Subclause 9.13, &quot;Collation determination&quot;. The comparison of two character string expressions depends on the collation used for the comparison (see Subclause 9.13, &quot;Collation determination&quot;). When values of unequal length are compared, if the collation for the comparison has the NO PAD characteristic and the shorter value is equal to some prefix of the longer value, then the shorter value is considered less than the longer value. If the collation for the comparison has the PAD SPACE characteristic, for the purposes of the comparison, the shorter value is effectively extended to the length of the longer by concatenation of &lt;space> s on the right. For every character set, there is at least one collation.&#xD;&#xA;"/>
      </eAnnotations>
      <eLiterals name="IMPLICIT"/>
      <eLiterals name="EXPLICIT" value="1"/>
      <eLiterals name="COERCIBILE" value="2"/>
      <eLiterals name="NO_COLLATION" value="3"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TimeDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.6.1 Datetimes&#xD;&#xA;&#xD;&#xA;Table 2, &quot;Fields in datetime values&quot; , specifies the fields that can make up a datetime value; a datetime value is made up of a subset of those fields. Not all of the fields shown are required to be in the subset, but every field that appears in the table between the first included primary field and the last included primary field shall also be included. If either time zone field is in the subset, then both of them shall be included.&#xD;&#xA;&#xD;&#xA;There is an ordering of the significance of &lt;primary datetime field> s. This is, from most significant to least significant: YEAR , MONTH , DAY , HOUR , MINUTE , and SECOND .&#xD;&#xA;&#xD;&#xA;The &lt;primary datetime field> s other than SECOND contain non-negative integer values, constrained by the natural rules for dates using the Gregorian calendar. SECOND , however, can be defined to have a &lt;time fractional seconds precision> that indicates the number of decimal digits maintained following the decimal point in the seconds value, a non-negative exact numeric value.&#xD;&#xA;&#xD;&#xA;There are three classes of datetime data types defined within this part of ISO/IEC 9075:&#xD;&#xA; - DATE: contains the &lt;primary datetime field> s YEAR , MONTH , and DAY .&#xD;&#xA; - TIME: contains the &lt;primary datetime field> s HOUR , MINUTE , and SECOND .&#xD;&#xA; - TIMESTAMP: contains the &lt;primary datetime field> s YEAR , MONTH , DAY , HOUR , MINUTE , and SECOND .&#xD;&#xA;&#xD;&#xA;Items of type datetime are comparable only if they have the same &lt;primary datetime field> s. A datetime data type that specifies WITH TIME ZONE is a data type that is datetime with time zone, while a datetime data type that specifies WITHOUT TIME ZONE is a data type that is datetime without time zone. The surface of the earth is divided into zones, called time zones, in which every correct clock tells the same time, known as local time. Local time is equal to UTC (Coordinated Universal Time) plus the time zone displacement, which is an interval value that ranges between INTERVAL '-12:59' HOUR TO MINUTE and INTERVAL '+14:00' HOUR TO MINUTE . The time zone displacement is constant throughout a time zone, changing at the beginning and end of Daylight Time, where applicable.&#xD;&#xA;&#xD;&#xA;A datetime value, of data type TIME WITHOUT TIME ZONE or TIMESTAMP WITHOUT TIME ZONE , may represent a local time, whereas a datetime value of data type TIME WITH TIME ZONE or TIMESTAMP WITH TIME ZONE represents UTC.&#xD;&#xA;&#xD;&#xA;On occasion, UTC is adjusted by the omission of a second or the insertion of a &quot;leap second&quot; in order to maintain synchronization with sidereal time. This implies that sometimes, but very rarely, a particular minute will contain exactly 59, 61, or 62 seconds. Whether an SQL-implementation supports leap seconds, and the consequences of such support for date and interval arithmetic, is implementation-defined.&#xD;&#xA;For the convenience of users, whenever a datetime value with time zone is to be implicitly derived from one without (for example, in a simple assignment operation), SQL assumes the value without time zone to be local, subtracts the current default time zone displacement of the SQL-session from it to give UTC, and associates that time zone displacement with the result. Conversely, whenever a datetime value without time zone is to be implicitly derived from one with, SQL assumes the value with time zone to be UTC, adds the time zone displacement to it to give local time, and the result, without any time zone displacement, is local. The preceding principles, as implemented by &lt;cast specification> , result in data type conversions between the various datetime data types, as summarized in Table 3, &quot;Datetime data type conversions&quot;.&#xD;&#xA;&#xD;&#xA;A datetime is assignable to a site only if the source and target of the assignment are both of type DATE , or both of type TIME (regardless whether WITH TIME ZONE or WITHOUT TIME ZONE is specified or implicit), or both of type TIMESTAMP (regardless whether WITH TIME ZONE or WITHOUT TIME ZONE is specified or implicit).&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="fractionalSecondsPrecision"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="timeZone" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="false"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="IntervalQualifierType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.6.2 Intervals&#xD;&#xA;&#xD;&#xA;There are two classes of intervals. One class, called year-month intervals, has an express or implied datetime precision that includes no fields other than YEAR and MONTH , though not both are required. The other class, called day-time intervals, has an express or implied interval precision that can include any fields other than YEAR or MONTH .&#xD;&#xA;&#xD;&#xA;The actual subset of fields that comprise a value of either type of interval is defined by an &lt;interval qualifier> and this subset is known as the precision of the value. Within a value of type interval, the first field is constrained only by the &lt;interval leading field precision> of the associated &lt;interval qualifier> . Table 6, &quot;Valid values for fields in INTERVAL values&quot;, specifies the constraints on subsequent field values.&#xD;&#xA;"/>
      </eAnnotations>
      <eLiterals name="YEAR"/>
      <eLiterals name="MONTH" value="1"/>
      <eLiterals name="DAY" value="2"/>
      <eLiterals name="HOUR" value="3"/>
      <eLiterals name="MINUTE" value="4"/>
      <eLiterals name="SECOND" value="5"/>
      <eLiterals name="FRACTION" value="6"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DistinctUserDefinedType" eSuperTypes="#//datatypes/UserDefinedType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.7 User-defined types&#xD;&#xA;&#xD;&#xA;A user-defined type is a schema object, identified by a &lt;user-defined type name> . The definition of a userdefined type specifies a number of components, including in particular a list of attribute definitions. Although the attribute definitions are said to define the representation of the user-defined type, in fact they implicitly define certain functions (observers and mutators) that are part of the interface of the user-defined type; physical representations of user-defined type values are implementation-dependent.&#xD;&#xA;&#xD;&#xA;The representation of a user-defined type is expressed either as a single data type (some predefined data type, called the source type), in which case the user-defined type is said to be a distinct type, or as a list of attribute definitions, in which case it is said to be a structured type.&#xD;&#xA;&#xD;&#xA;A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:&#xD;&#xA; - The name of the user-defined type (&lt;user-defined type name> ). This is the type designator of that type, used in type precedence lists (see Subclause 9.5, &quot;Type precedence list determination&quot;).&#xD;&#xA; - An indication of whether the user-defined type is a structured type or a distinct type."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="predefinedRepresentation"
          lowerBound="1" eType="#//datatypes/PredefinedDataType" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="StructuredUserDefinedType" eSuperTypes="#//datatypes/UserDefinedType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.7 User-defined types&#xD;&#xA;&#xD;&#xA;A user-defined type is a schema object, identified by a &lt;user-defined type name> . The definition of a userdefined type specifies a number of components, including in particular a list of attribute definitions. Although the attribute definitions are said to define the representation of the user-defined type, in fact they implicitly define certain functions (observers and mutators) that are part of the interface of the user-defined type; physical representations of user-defined type values are implementation-dependent.&#xD;&#xA;&#xD;&#xA;The representation of a user-defined type is expressed either as a single data type (some predefined data type, called the source type), in which case the user-defined type is said to be a distinct type, or as a list of attribute definitions, in which case it is said to be a structured type.&#xD;&#xA;&#xD;&#xA;A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:&#xD;&#xA; - The name of the user-defined type (&lt;user-defined type name> ). This is the type designator of that type, used in type precedence lists (see Subclause 9.5, &quot;Type precedence list determination&quot;).&#xD;&#xA; - An indication of whether the user-defined type is a structured type or a distinct type."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="instantiable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="True"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="final" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="super" eType="#//datatypes/StructuredUserDefinedType"
          eOpposite="#//datatypes/StructuredUserDefinedType/sub"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="sub" upperBound="-1"
          eType="#//datatypes/StructuredUserDefinedType" eOpposite="#//datatypes/StructuredUserDefinedType/super"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="attributes" upperBound="-1"
          eType="#//datatypes/AttributeDefinition" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="methods" upperBound="-1"
          eType="#//routines/Method" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="OrderingType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.7 User-defined types&#xD;&#xA;&#xD;&#xA;A user-defined type is a schema object, identified by a &lt;user-defined type name>.&#xD;&#xA;&#xD;&#xA;A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:&#xD;&#xA; - The name of the user-defined type (&lt;user-defined type name> ). This is the type designator of that type, used in type precedence lists (see Subclause 9.5, &quot;Type precedence list determination&quot;).&#xD;&#xA; - An indication of whether the user-defined type is a structured type or a distinct type.&#xD;&#xA; - The ordering form for the user-defined type (EQUALS , FULL , or NONE ).&#xD;&#xA; - The ordering category for the user-defined type (RELATIVE , MAP , or STATE )."/>
      </eAnnotations>
      <eLiterals name="EQUALS"/>
      <eLiterals name="FULL" value="1"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="OrderingCategoryType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.7 User-defined types&#xD;&#xA;&#xD;&#xA;A user-defined type is a schema object, identified by a &lt;user-defined type name>.&#xD;&#xA;&#xD;&#xA;A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:&#xD;&#xA; - The name of the user-defined type (&lt;user-defined type name> ). This is the type designator of that type, used in type precedence lists (see Subclause 9.5, &quot;Type precedence list determination&quot;).&#xD;&#xA; - An indication of whether the user-defined type is a structured type or a distinct type.&#xD;&#xA; - The ordering form for the user-defined type (EQUALS , FULL , or NONE ).&#xD;&#xA; - The ordering category for the user-defined type (RELATIVE , MAP , or STATE )."/>
      </eAnnotations>
      <eLiterals name="RELATIVE"/>
      <eLiterals name="MAP" value="1"/>
      <eLiterals name="STATE" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="AttributeDefinition" eSuperTypes="#//schema/TypedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.13 Columns, fields, and attributes&#xD;&#xA;&#xD;&#xA;The terms column, field, and attribute refer to structural components of tables, row types, and structured types, respectively, in analogous fashion. As the structure of a table consists of one or more columns, so does the structure of a row type consist of one or more fields and that of a structured type one or more attributes. Every structural element, whether a column, a field, or an attribute, is primarily a name paired with a declared type.&#xD;&#xA;&#xD;&#xA;The elements of a structure are ordered. Elements in different positions in the same structure can have the same declared type but not the same name. Although the elements of a structure are distinguished from each other by name, in some circumstances the compatibility of two structures (for the purpose at hand) is determined solely by considering the declared types of each pair of elements at the same ordinal position.&#xD;&#xA;&#xD;&#xA;An attribute A is described by an attribute descriptor. An attribute descriptor includes:&#xD;&#xA; - The name of the attribute.&#xD;&#xA; - The data type descriptor of the declared type of A.&#xD;&#xA; - The ordinal position of A within the structured type that contains it.&#xD;&#xA; - The value of the implicit or explicit &lt;attribute default> of A.&#xD;&#xA; - If the data type of the attribute is a reference type, then an indication of whether reference values shall be checked, and the &lt;reference scope check action> , if specified or implied.&#xD;&#xA; - The name of the structured type defined by the &lt;user-defined type definition> that defines A.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeCheck" eType="#//schema/ReferentialActionType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeChecked" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="defaultValue" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FixedPrecisionDataType" eSuperTypes="#//datatypes/ExactNumericDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;For reference purposes:&#xD;&#xA;[...]&#xD;&#xA; - The data types NUMERIC , DECIMAL , SMALLINT , INTEGER , and BIGINT are collectively referred to as exact numeric types.&#xD;&#xA; - The data types FLOAT , REAL , and DOUBLE PRECISION are collectively referred to as approximate numeric types.&#xD;&#xA; - Exact numeric types and approximate numeric types are collectively referred to as numeric types. Values of numeric types are referred to as numbers.&#xD;&#xA;&#xD;&#xA;4.4.1 Characteristics of numbers&#xD;&#xA;&#xD;&#xA;An exact numeric type has a precision P and a scale S. P is a positive integer that determines the number of significant digits in a particular radix R, where R is either 2 or 10. S is a non-negative integer. Every value of an exact numeric type of scale S is of the form n x 10-S, where n is an integer such that -RP &lt;= n &lt; RP.&#xD;&#xA;NOTE 13 - Not every value in that range is necessarily a value of the type in question.&#xD;&#xA;&#xD;&#xA;An approximate numeric value consists of a mantissa and an exponent. The mantissa is a signed numeric value, and the exponent is a signed integer that specifies the magnitude of the mantissa. An approximate numeric value has a precision. The precision is a positive integer that specifies the number of significant binary digits in the mantissa. The value of an approximate numeric value is the mantissa multiplied by a factor determined by the exponent.&#xD;&#xA;&#xD;&#xA;An &lt;approximate numeric literal> ANL consists of an &lt;exact numeric literal> (called the &lt;mantissa> ), the letter 'E' or 'e', and a &lt;signed integer> (called the &lt;exponent> ). If M is the value of the &lt;mantissa> and E is the value of the &lt;exponent> , then M * 10E is the apparent value of ANL. The actual value of ANL is approximately the apparent value of ANL, according to implementation-defined rules.&#xD;&#xA;"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="PrimitiveType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;Every predefined data type is a subtype of itself and of no other data types. It follows that every predefined data type is a supertype of itself and of no other data types. The predefined data types are individually described in each of Subclause 4.2, &quot;Character strings&quot;, through Subclause 4.6, &quot;Datetimes and intervals&quot;. Row types, reference types and collection types are described in Subclause 4.8, &quot;Row types&quot;, Subclause 4.9, &quot;Reference types&quot;, Subclause 4.10, &quot;Collection types&quot;, respectively.&#xD;&#xA;&#xD;&#xA;SQL defines predefined data types named by the following &lt;key word> s: CHARACTER , CHARACTER VARYING , CHARACTER LARGE OBJECT , BINARY LARGE OBJECT , NUMERIC , DECIMAL , SMALLINT , INTEGER , BIGINT , FLOAT , REAL , DOUBLE PRECISION , BOOLEAN , DATE , TIME , TIMESTAMP , and INTERVAL . These names are used in the type designators that constitute the type precedence lists specified in Subclause 9.5, &quot;Type precedence list determination&quot;."/>
      </eAnnotations>
      <eLiterals name="CHARACTER"/>
      <eLiterals name="CHARACTER_VARYING" value="1"/>
      <eLiterals name="CHARACTER_LARGE_OBJECT" value="2"/>
      <eLiterals name="NATIONAL_CHARACTER" value="3"/>
      <eLiterals name="NATIONAL_CHARACTER_VARYING" value="4"/>
      <eLiterals name="NATIONAL_CHARACTER_LARGE_OBJECT" value="5"/>
      <eLiterals name="BINARY" value="6"/>
      <eLiterals name="BINARY_VARYING" value="7"/>
      <eLiterals name="BINARY_LARGE_OBJECT" value="8"/>
      <eLiterals name="NUMERIC" value="9"/>
      <eLiterals name="DECIMAL" value="10"/>
      <eLiterals name="SMALLINT" value="11"/>
      <eLiterals name="INTEGER" value="12"/>
      <eLiterals name="BIGINT" value="13"/>
      <eLiterals name="FLOAT" value="14"/>
      <eLiterals name="REAL" value="15"/>
      <eLiterals name="DOUBLE_PRECISION" value="16"/>
      <eLiterals name="BOOLEAN" value="17"/>
      <eLiterals name="DATE" value="18"/>
      <eLiterals name="TIME" value="19"/>
      <eLiterals name="TIMESTAMP" value="20"/>
      <eLiterals name="INTERVAL" value="21"/>
      <eLiterals name="DATALINK" value="22"/>
      <eLiterals name="XML_TYPE" value="23"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Domain" eSuperTypes="#//datatypes/DistinctUserDefinedType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.12 Domains&#xD;&#xA;&#xD;&#xA;A domain is a set of permissible values. A domain is defined in a schema and is identified by a &lt;domain name> . The purpose of a domain is to constrain the set of valid values that can be stored in a column of a base table by various operations.&#xD;&#xA;&#xD;&#xA;A domain definition specifies a data type. It may also specify a &lt;domain constraint> that further restricts the valid values of the domain and a &lt;default clause> that specifies the value to be used in the absence of an explicitly specified value or column default.&#xD;&#xA;&#xD;&#xA;A domain is described by a domain descriptor. A domain descriptor includes:&#xD;&#xA; - The name of the domain.&#xD;&#xA; - The data type descriptor of the data type of the domain.&#xD;&#xA; - The value of &lt;default option> , if any, of the domain.&#xD;&#xA; - The domain constraint descriptors of the domain constraints, if any, of the domain.&#xD;&#xA;&#xD;&#xA;4.17.3 Domain constraints&#xD;&#xA;&#xD;&#xA;A domain constraint is a constraint that is specified for a domain. It is applied to all columns that are based on that domain, and to all values cast to that domain. A domain constraint is described by a domain constraint descriptor. In addition to the components of every constraint descriptor a domain constraint descriptor includes:&#xD;&#xA; - The &lt;search condition> .&#xD;&#xA;&#xD;&#xA;A domain constraint is satisfied by SQL-data if and only if, for any table T that has a column named C based on that domain, the specified &lt;search condition> , with each occurrence of VALUE replaced by C, is not False for any row of T. A domain constraint is satisfied by the result of a &lt;cast specification> if and only if the specified &lt;search condition>, with each occurrence of VALUE replaced by that result, is not False."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constraint" upperBound="-1"
          eType="#//constraints/CheckConstraint" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="defaultValue" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Field" eSuperTypes="#//schema/TypedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.13 Columns, fields, and attributes&#xD;&#xA;&#xD;&#xA;The terms column, field, and attribute refer to structural components of tables, row types, and structured types, respectively, in analogous fashion. As the structure of a table consists of one or more columns, so does the structure of a row type consist of one or more fields and that of a structured type one or more attributes. Every structural element, whether a column, a field, or an attribute, is primarily a name paired with a declared type.&#xD;&#xA;&#xD;&#xA;The elements of a structure are ordered. Elements in different positions in the same structure can have the same declared type but not the same name. Although the elements of a structure are distinguished from each other by name, in some circumstances the compatibility of two structures (for the purpose at hand) is determined solely by considering the declared types of each pair of elements at the same ordinal position.&#xD;&#xA;&#xD;&#xA;A field F is described by a field descriptor. A field descriptor includes:&#xD;&#xA; - The name of the field.&#xD;&#xA; - The data type descriptor of the declared type of F.&#xD;&#xA; - The ordinal position of F within the row type that simply contains it.&#xD;&#xA; - If the data type of the field is a reference type, then an indication of whether reference values shall be checked, and the &lt;reference scope check action> , if specified or implied.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeCheck" eType="#//schema/ReferentialActionType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeChecked" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ReferenceDataType" abstract="true"
        eSuperTypes="#//datatypes/ConstructedDataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.1 Data types&#xD;&#xA;&#xD;&#xA;A data type is a set of representable values. Every representable value belongs to at least one data type and some belong to several data types. [...]&#xD;&#xA;&#xD;&#xA;A constructed type is specified using one of SQL's data type constructors, ARRAY , MULTISET , REF , and ROW . A constructed type is either an array type, a multiset type, a reference type, or a row type, according to whether it is specified with ARRAY , MULTISET , REF , or ROW , respectively. Array types and multiset types are known generically as collection types.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="scopeTable" lowerBound="1"
          eType="#//tables/Table"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="referencedType" lowerBound="1"
          eType="#//datatypes/StructuredUserDefinedType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ConstructedDataType" abstract="true"
        eSuperTypes="#//datatypes/SQLDataType"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLDataType" abstract="true" eSuperTypes="#//datatypes/DataType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="SQLDataType represents any non user defined data type.  I was introduced because a TypedElement needs to distinguish between UDTs and non UDTs."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DataLinkDataType" eSuperTypes="#//datatypes/PredefinedDataType">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="length" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="linkControl" eType="#//datatypes/LinkControlOption"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="integrityControl" eType="#//datatypes/IntegrityControlOption"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="readPermission" eType="#//datatypes/ReadPermissionOption"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="writePermission" eType="#//datatypes/WritePermissionOption"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="recovery" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="unlink" eType="#//datatypes/UnlinkOption"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="LinkControlOption">
      <eLiterals name="FILE_LINK_CONTROL"/>
      <eLiterals name="NO_FILE_LINK_CONTROL" value="1"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="IntegrityControlOption">
      <eLiterals name="ALL"/>
      <eLiterals name="SELECTIVE" value="1"/>
      <eLiterals name="NONE" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ReadPermissionOption">
      <eLiterals name="FS"/>
      <eLiterals name="DB" value="1"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="WritePermissionOption">
      <eLiterals name="FS"/>
      <eLiterals name="ADMIN" value="1"/>
      <eLiterals name="BLOCKED" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="UnlinkOption">
      <eLiterals name="RESTORE"/>
      <eLiterals name="DELETE" value="1"/>
      <eLiterals name="NONE" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="UserDefinedTypeOrdering" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="orderingForm" eType="#//datatypes/OrderingType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="orderingCategory" eType="#//datatypes/OrderingCategoryType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="orderingRoutine" lowerBound="1"
          eType="#//routines/Routine"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DateDataType" eSuperTypes="#//datatypes/PredefinedDataType"/>
    <eClassifiers xsi:type="ecore:EClass" name="ExactNumericDataType" abstract="true"
        eSuperTypes="#//datatypes/NumericalDataType">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scale" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ApproximateNumericDataType" eSuperTypes="#//datatypes/NumericalDataType"/>
    <eClassifiers xsi:type="ecore:EClass" name="IntegerDataType" eSuperTypes="#//datatypes/ExactNumericDataType"/>
    <eClassifiers xsi:type="ecore:EClass" name="XMLDataType" eSuperTypes="#//datatypes/PredefinedDataType"/>
  </eSubpackages>
  <eSubpackages name="expressions" nsURI="http:///org/eclipse/datatools/modelbase/sql/expressions.ecore"
      nsPrefix="SQLExpressions">
    <eClassifiers xsi:type="ecore:EClass" name="QueryExpression" abstract="true" interface="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A boolean value expression specifying a condition that is True, False, or Unknown.&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="getSQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eOperations name="setSQL">
        <eParameters name="sqlText" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ValueExpression" abstract="true" interface="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14.5 Base columns and generated columns&#xD;&#xA;&#xD;&#xA;A column of a base table is either a base column or a generated column. A base column is one that is not a generated column.&#xD;&#xA;&#xD;&#xA;A generated column is one whose values are determined by evaluation of a generation expression, a &lt;value expression> whose declared type is by implication that of the column.&#xD;&#xA;&#xD;&#xA;A generation expression can reference base columns of the base table to which it belongs but cannot otherwise access SQLdata. Thus, the value of the field corresponding to a generated column in row R is determined by the values of zero or more other fields of R.&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="getSQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eOperations name="setSQL">
        <eParameters name="sqlText" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SearchCondition" abstract="true" interface="true">
      <eOperations name="getSQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eOperations name="setSQL">
        <eParameters name="sqlText" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="QueryExpressionDefault" eSuperTypes="#//schema/SQLObject #//expressions/QueryExpression">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="SQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SearchConditionDefault" eSuperTypes="#//schema/SQLObject #//expressions/SearchCondition">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="SQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ValueExpressionDefault" eSuperTypes="#//schema/SQLObject #//expressions/ValueExpression">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="SQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="routines" nsURI="http:///org/eclipse/datatools/modelbase/sql/routines.ecore"
      nsPrefix="SQLRoutines">
    <eClassifiers xsi:type="ecore:EClass" name="Routine" abstract="true" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is described by a routine descriptor. A routine descriptor includes:&#xD;&#xA;- The routine name of the SQL-invoked routine.&#xD;&#xA;- The specific name of the SQL-invoked routine.&#xD;&#xA;- The routine authorization identifier of the SQL-invoked routine.&#xD;&#xA;- The name of the language in which the body of the SQL-invoked routine is written.&#xD;&#xA;- For each of the SQL-invoked routine's SQL parameters, the &lt;SQL parameter name> , if it is specified, the &lt;data type> , the ordinal position, and an indication of   whether the SQL parameter is an input SQL parameter, an output SQL parameter, or both an input SQL parameter and an output SQL parameter.&#xD;&#xA;- An indication of whether the SQL-invoked routine is an SQL-invoked function or an SQL-invoked procedure.&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked procedure, then the maximum number of dynamic result sets.&#xD;&#xA;- An indication of whether the SQL-invoked routine is deterministic or possibly non-deterministic.&#xD;&#xA;- Indications of whether the SQL-invoked routine possibly modifies SQL-data, possibly reads SQL-data, possibly contains SQL, or does not possibly contain SQL.&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked function, then:&#xD;&#xA;  * The &lt;returns data type> of the SQL-invoked function.&#xD;&#xA;  * If the &lt;returns data type> simply contains &lt;locator indication> , then an indication that the return value is a locator.&#xD;&#xA;  * An indication of whether the SQL-invoked function is a null-call function.&#xD;&#xA;  * An indication of whether the SQL-invoked function is an SQL-invoked method.&#xD;&#xA;- The creation timestamp.&#xD;&#xA;- The last-altered timestamp.&#xD;&#xA;- If the SQL-invoked routine is an SQL routine, then:&#xD;&#xA;  * The SQL routine body of the SQL-invoked routine.&#xD;&#xA;  * The SQL security characteristic of the SQL routine.&#xD;&#xA;- If the SQL-invoked routine is an external routine, then:&#xD;&#xA;  * The external routine name of the external routine.&#xD;&#xA;  * The &lt;parameter style> of the external routine.&#xD;&#xA;  * If the external routine specifies a &lt;result cast>, then an indication that it specifies a &lt;result cast> and the &lt;data type> specified in the &lt;result cast> . If &lt;result cast> contains &lt;locator indication> , then an indication that the &lt;data type> specified in the &lt;result cast> has a locator indication.&#xD;&#xA;  * The external security characteristic of the external routine.&#xD;&#xA;  * The external routine authorization identifier of the external routine.&#xD;&#xA;  * The effective SQL parameter list of the external routine.&#xD;&#xA;  * For every SQL parameter whose &lt;SQL parameter declaration> contains &lt;locator indication> , an indication that the SQL parameter is a locator parameter.&#xD;&#xA;- The schema name of the schema that includes the SQL-invoked routine.&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked method, then:&#xD;&#xA;  * An indication of the user-defined type whose descriptor contains the corresponding method specification descriptor.&#xD;&#xA;  * An indication of whether STATIC was specified.&#xD;&#xA;- An indication of whether the SQL-invoked routine is dependent on a user-defined type.&#xD;&#xA;- An indication as to whether or not the SQL-invoked routine requires a new savepoint level to be established when it is invoked.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Not included:&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;- The routine SQL-path of the SQL-invoked routine is not included because the SQL-path, which I read as CURRENT SCHEMA in DB2 land, of the current SQL-session.&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked function, then:&#xD;&#xA;  * An indication of whether the SQL-invoked function is a type-preserving function or not.&#xD;&#xA;  * An indication of whether the SQL-invoked function is a mutator function or not.&#xD;&#xA;  * If the SQL-invoked function is a type-preserving function, then an indication of which parameter is the result parameter.&#xD;&#xA;- If the SQL-invoked routine is an external routine, then:&#xD;&#xA;  * The external routine SQL-path of the external routine.&#xD;&#xA;  * For every SQL parameter that has an associated from-sql function FSF, the specific name of FSF.&#xD;&#xA;  * For every SQL parameter that has an associated to-sql function TSF, the specific name of TSF.&#xD;&#xA;  * If the SQL-invoked routine is an external function and if it has a to-sql function TRF associated with the result, then the specific name of TRF.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="specificName" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is uniquely identified by a &lt;specific name> , called the specific name of the SQLinvoked&#xD;&#xA;routine.&#xD;&#xA;&#xD;&#xA;Typically qualified with a schema name. &#xD;&#xA;"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="language" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Since there are many languages, rather than constrain ourselves to an enumerated list which is difficult to subclass in the EMF environment, we have chosen to use strings.&#xD;&#xA;&#xD;&#xA;JAVA&#xD;&#xA;SQL&#xD;&#xA;PERL&#xD;&#xA;C&#xD;&#xA;ADA&#xD;&#xA;COBOL&#xD;&#xA;FORTRAN&#xD;&#xA;MUMPS&#xD;&#xA;PASCAL&#xD;&#xA;PLI&#xD;&#xA;and so on..."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="parameterStyle" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Paraphrased from 5WD-02-Foundation-2002-12 &#xD;&#xA;The spec only calls for two. Though it seems like an easy choice for enumeration as in the language attribute, other vendors have different styles and since enumeration is not good to subclass within the EMF tooling framework, a string representation is used.&#xD;&#xA;&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;SQL &#xD;&#xA;GENERAL.&#xD;&#xA;&#xD;&#xA;Used in stored procedures, user defined functions, and methods.&#xD;&#xA;&#xD;&#xA;"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="deterministic" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is either deterministic or possibly non-deterministic. An SQL-invoked function that&#xD;&#xA;is deterministic always returns the identical return value for a given list of SQL argument values. An SQLinvoked&#xD;&#xA;procedure that is deterministic always returns the identical values in its output and inout SQL parameters&#xD;&#xA;for a given list of SQL argument values. An SQL-invoked routine is possibly non-deterministic if it might&#xD;&#xA;produce nonidentical results when invoked with the identical list of SQL argument values."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="sqlDataAccess" eType="#//routines/DataAccess">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&#xD;&#xA;&lt;SQL-data access indication> ::= NO SQL | CONTAINS SQL | READS SQL DATA | MODIFIES SQL DATA&#xD;&#xA;&#xD;&#xA;(see DataAccess enumeration class)"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="creationTS" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is described by a routine descriptor. A routine descriptor includes:&#xD;&#xA;- The creation timestamp.&#xD;&#xA;&#xD;&#xA;Because there is no provision in the spec as to the format of the timestamp, it is left to the individual implementers to determine the format."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="lastAlteredTS" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is described by a routine descriptor. A routine descriptor includes:&#xD;&#xA;- The last-altered timestamp.&#xD;&#xA;&#xD;&#xA;Because there is no provision in the spec as to the format of the timestamp, it is left to the individual implementers to determine the format."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="authorizationID" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine has a routine authorization identifier, which is (directly or indirectly) the authorization&#xD;&#xA;identifier of the owner of the schema that contains the SQL-invoked routine at the time that the SQL-invoked&#xD;&#xA;routine is created."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="security" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From the below, typical values would be: &quot;DEFINER&quot;, &quot;INVOKER&quot;, &quot;IMPLEMENTATION DEFINED&quot;&#xD;&#xA;Since there are several implementation defined security designations, it is best to go with the string.&#xD;&#xA;&#xD;&#xA;From 5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&#xD;&#xA;&lt;external security clause> ::=&#xD;&#xA;  EXTERNAL SECURITY DEFINER&#xD;&#xA;  | EXTERNAL SECURITY INVOKER&#xD;&#xA;  | EXTERNAL SECURITY IMPLEMENTATION DEFINED&#xD;&#xA;&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;If the SQL-invoked routine is an SQL routine, then the identifiers are determined according to the SQL security&#xD;&#xA;characteristic of the SQL-invoked routine:&#xD;&#xA;- If the SQL security characteristic is DEFINER , then:&#xD;&#xA;  * If the routine authorization identifier is a user identifier, the user identifier is set to the routine authorization&#xD;&#xA;    identifier and the role name is set to null.&#xD;&#xA;  * Otherwise, the role name is set to the routine authorization identifier and the user identifier is set to&#xD;&#xA;    null.&#xD;&#xA;- If the SQL security characteristic is INVOKER , then the identifiers remain unchanged.      &#xD;&#xA;If the SQL-invoked routine is an external routine, then the identifiers are determined according to the external&#xD;&#xA;security characteristic of the SQL-invoked routine:&#xD;&#xA;- If the external security characteristic is DEFINER , then:&#xD;&#xA;  * If the routine authorization identifier is a user identifier, then the user identifier is set to the routine&#xD;&#xA;    authorization identifier and the role name is set to the null value.&#xD;&#xA;  * Otherwise, the role name is set to the routine authorization identifier and the user identifier is set to the&#xD;&#xA;    null value.&#xD;&#xA;- If the external security characteristic is INVOKER , then the identifiers remain unchanged.&#xD;&#xA;- If the external security characteristic is IMPLEMENTATION DEFINED , then the identifiers are set to&#xD;&#xA;implementation-defined values."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="externalName" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;from 11.50 SQL-invoked routine:&#xD;&#xA;&#xD;&#xA;The external name of the routine descriptor is &lt;external routine name> .&#xD;&#xA;&lt;external body reference> ::= EXTERNAL [ NAME &lt;external routine name> ] [ &lt;parameter&#xD;&#xA;style clause> ] [ &lt;transform group specification> ] [ &lt;external security clause> ]&#xD;&#xA;&#xD;&#xA;from 4.27 SQL-invoked routines&#xD;&#xA;&lt;external routine name> identifies a program written in some&#xD;&#xA;standard programming language other than SQL .&#xD;&#xA;&#xD;&#xA;from 5.4 Names and identifiers&#xD;&#xA;&lt;external routine name> ::= &lt;identifier> | &lt;character string literal>&#xD;&#xA;An &lt;external routine name> identifies an external routine."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="parameters" upperBound="-1"
          eType="#//routines/Parameter" containment="true" eOpposite="#//routines/Parameter/routine"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="source" eType="#//routines/Source"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/routines"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Source" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.23 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine is described by a routine descriptor. A routine descriptor contains (among other things):&#xD;&#xA;- If the SQL-invoked routine is an SQL routine, then the SQL routine body of the SQL-invoked routine."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="body" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Parameter" eSuperTypes="#//schema/TypedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;11.49 &lt;SQL-invoked routine>&#xD;&#xA;&lt;SQL parameter declaration> ::= [ &lt;parameter mode> ] [ &lt;SQL parameter name> ] &lt;parameter type> [ RESULT ]&#xD;&#xA;&#xD;&#xA;4.23 SQL-invoked routines&#xD;&#xA;For every SQL parameter whose &lt;SQL parameter declaration> contains &lt;locator indication>, an indication that the SQL parameter is a locator parameter.&#xD;&#xA;&#xD;&#xA;4.26.4 Locators&#xD;&#xA;A host parameter, an SQL parameter of an external routine, or the value returned by an external function may be specified to be a locator by specifying AS LOCATOR. A locator is an SQL-session object, rather than SQL-data, that can be used to reference an SQL-data instance. A locator is either a large object locator, an user-defined type locator, or an array locator. A large object locator&#xD;&#xA;is one of the following:&#xD;&#xA;- Binary large object locator, a value of which identifies a binary large object.&#xD;&#xA;- Character large object locator, a value of which identifies a character large object.&#xD;&#xA;- National character large object locator, a value of which identifies a national character large object.&#xD;&#xA;&#xD;&#xA;11.49 &lt;SQL-invoked routine>&#xD;&#xA;&lt;parameter type> ::= &lt;data type> [ &lt;locator indication> ] &#xD;&#xA;&#xD;&#xA;&lt;locator indication> ::= AS LOCATOR&#xD;&#xA;&#xD;&#xA;---------------------&#xD;&#xA;from Information technology - Database languages - SQL - Part 14: XML-Related Specifications (SQL/XML)&#xD;&#xA;&#xD;&#xA;12.7 &lt;SQL-invoked routine>&#xD;&#xA;&lt;parameter type> ::= &lt;data type> [ &lt;locator indication> ] [ &lt;document or content> ] [ &lt;string type option> ]&#xD;&#xA;&lt;returns data type> ::= &lt;data type> [ &lt;locator indication> ] [ &lt;document or content> ] [ &lt;string type option> ]&#xD;&#xA;&lt;string type option> ::= AS &lt;character string type>&#xD;&#xA;&#xD;&#xA;Both [ &lt;document or content> ] [ &lt;string type option> ] are in support of the XML enhancements to SQL:2003."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="mode" eType="#//routines/ParameterMode">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="5WD-02-Foundation-2002-12&#xD;&#xA;&#xD;&#xA;&lt;SQL parameter declaration> ::= [ &lt;parameter mode> ] [ &lt;SQL parameter name> ] &lt;parameter type> [ RESULT ]&#xD;&#xA;&#xD;&#xA;&lt;parameter mode> ::= IN | OUT | INOUT&#xD;&#xA;&#xD;&#xA;For functions, defaults to IN.&#xD;&#xA;See enumerated class ParameterMode"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="locator" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="5WD-02-Foundation-2002-12&#xD;&#xA;4.29.4 Locators&#xD;&#xA;A host parameter, a host variable, an SQL parameter of an external routine, or the value returned by an external&#xD;&#xA;function may be specified to be a locator by specifying AS LOCATOR . A locator is an SQL-session object,&#xD;&#xA;rather than SQL-data, that can be used to reference an SQL-data instance. A locator is either a large object&#xD;&#xA;locator, a user-defined type locator, an array locator, or a multiset locator. &#xD;&#xA;&#xD;&#xA;A large object locator is one of the following:&#xD;&#xA;- Binary large object locator, a value of which identifies a binary large object.&#xD;&#xA;- Character large object locator, a value of which identifies a large object character string.&#xD;&#xA;- National character large object locator, a value of which identifies a national large object character string.&#xD;&#xA;&#xD;&#xA;A user-defined type locator identifies a value of the user-defined type specified by the locator specification.&#xD;&#xA;An array locator identifies a value of the array type specified by the locator specification. A multiset locator&#xD;&#xA;identifies a value of the multiset type specified by the locator specification."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="routine" lowerBound="1"
          eType="#//routines/Routine" transient="true" eOpposite="#//routines/Routine/parameters"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="stringTypeOption" eType="#//datatypes/CharacterStringDataType"
          containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Procedure" eSuperTypes="#//routines/Routine">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&#xD;&#xA;&lt;dynamic result sets characteristic> ::= DYNAMIC RESULT SETS &lt;maximum dynamic result sets>&#xD;&#xA;&#xD;&#xA;&lt;maximum dynamic result sets> ::= &lt;unsigned integer>&#xD;&#xA;&#xD;&#xA;&lt;savepoint level indication> ::= NEW SAVEPOINT LEVEL | OLD SAVEPOINT LEVEL"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="maxResultSets" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Maximun number of result sets the procedure can return.  If the stored procedure returns more result sets than is specified by this value, then a database error will be generated.&#xD;&#xA;&#xD;&#xA;From 5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&lt;dynamic result sets characteristic> ::= DYNAMIC RESULT SETS &lt;maximum dynamic result sets>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="oldSavePoint" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;An SQL-invoked procedure may optionally be specified to require a new savepoint level to be established when it is invoked and destroyed on return from the executed routine body. The alternative of not taking a savepoint can also be directly specified with OLD SAVEPOINT LEVEL . When an SQL-invoked function is invoked a new savepoint level is always established.&#xD;&#xA;&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&lt;savepoint level indication> ::= NEW SAVEPOINT LEVEL | OLD SAVEPOINT LEVEL"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="resultSet" upperBound="-1"
          eType="#//routines/RoutineResultTable" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Function" eSuperTypes="#//routines/Routine">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.23 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;...&#xD;&#xA;&#xD;&#xA;If the SQL-invoked routine is an SQL-invoked function, then:&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked function, then an indication of whether the SQL-invoked function is an SQL-invoked method.&#xD;&#xA;- The &lt;returns data type> of the SQL-invoked function.&#xD;&#xA;- If the &lt;returns data type> simply contains &lt;locator indication>, then an indication that the return value is a locator.&#xD;&#xA;- An indication of whether the SQL-invoked function is a type-preserving function or not.&#xD;&#xA;- An indication of whether the SQL-invoked function is a mutator function or not.&#xD;&#xA;- If the SQL-invoked function is a type-preserving function, then an indication of which parameter is the result parameter.&#xD;&#xA;- An indication of whether the SQL-invoked function is a null-call function.&#xD;&#xA;&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="nullCall" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&lt;null-call clause> ::= RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT&#xD;&#xA;&#xD;&#xA;If PROCEDURE is specified, then:&#xD;&#xA;- &lt;null-call clause> shall not be specified.&#xD;&#xA;&#xD;&#xA;if &lt;null-call clause> is not specified, then &#xD;&#xA;- CALLED ON NULL INPUT is implicit.&#xD;&#xA;&#xD;&#xA;If the SQL-invoked routine is an SQL-invoked function, then:&#xD;&#xA;- The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine&#xD;&#xA;is a null-call function.&#xD;&#xA;&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;A null-call function is an SQL-invoked function that is defined to return the null value if any of its input arguments is the null value. A null-call function is an SQL-invoked function whose &lt;null-call clause> specifies&#xD;&#xA;&quot;RETURNS NULL ON NULL INPUT&quot;."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="static" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&#xD;&#xA;&lt;dispatch clause> ::= STATIC DISPATCH&#xD;&#xA;&#xD;&#xA;If R is an SQL-invoked regular function and the &lt;SQL parameter declaration list> contains an&#xD;&#xA;&lt;SQL parameter declaration> that specifies a &lt;data type> that is one of:&#xD;&#xA;1) A user-defined type.&#xD;&#xA;2) A collection type whose element type is a user-defined type.&#xD;&#xA;3) A collection type whose element type is a reference type.&#xD;&#xA;4) A reference type.&#xD;&#xA;then &lt;dispatch clause> shall be specified. Otherwise, &lt;dispatch clause> shall not be specified."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="transformGroup" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="From 5WD-02-Foundation-2002-12&#xD;&#xA;4.7.5 Transforms for user-defined types&#xD;&#xA;&#xD;&#xA;Transforms are SQL-invoked functions that are automatically invoked when values of user-defined types are&#xD;&#xA;transferred from SQL-environment to host languages or vice-versa.&#xD;&#xA;&#xD;&#xA;A transform is associated with a user-defined type. A transform identifies a list of transform groups of up to&#xD;&#xA;two SQL-invoked functions, called the transform functions, each identified by a group name. The group name&#xD;&#xA;of a transform group is an &lt;identifier> such that no two transform groups for a transform have the same group&#xD;&#xA;name. The two transform functions are:&#xD;&#xA;- from-sql function : This SQL-invoked function maps the user-defined type value into a value of an SQL&#xD;&#xA;  pre-defined type, and gets invoked whenever a user-defined type value is passed to a host language &#xD;&#xA;  program or an external routine.&#xD;&#xA;- to-sql function : This SQL-invoked function maps a value of an SQL predefined type to a value of a&#xD;&#xA;  user-defined type and gets invoked whenever a user-defined type value is supplied by a host language&#xD;&#xA;  program or an external routine."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="typePreserving" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="mutator" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="returnTable" eType="#//routines/RoutineResultTable"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="returnScaler" eType="#//routines/Parameter"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="returnCast" eType="#//routines/Parameter"
          containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="DataAccess">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="5WD-02-Foundation-2002-12&#xD;&#xA;4.27 SQL-invoked routines&#xD;&#xA;&#xD;&#xA;An external routine either does not possibly contain SQL or possibly contains SQL. Only an external routine that possibly contains SQL may execute SQL-statements during its invocation.&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine may or may not possibly read SQL-data. Only an SQL-invoked routine that possibly reads SQL-data may read SQL-data during its invocation.&#xD;&#xA;&#xD;&#xA;An SQL-invoked routine may or may not possibly modify SQL-data. Only an SQL-invoked routine that possibly modifies SQL-data may modify SQL-data during its invocation.&#xD;&#xA;&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&lt;SQL-data access indication> ::= NO SQL | CONTAINS SQL | READS SQL DATA | MODIFIES SQL DATA"/>
      </eAnnotations>
      <eLiterals name="NO_SQL"/>
      <eLiterals name="CONTAINS_SQL" value="1"/>
      <eLiterals name="READS_SQL_DATA" value="2"/>
      <eLiterals name="MODIFIES_SQL_DATA" value="3"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ParameterMode">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="5WD-02-Foundation-2002-12&#xD;&#xA;11.50 &lt;SQL-invoked routine>&#xD;&#xA;&#xD;&#xA;&lt;parameter mode> ::= IN | OUT | INOUT"/>
      </eAnnotations>
      <eLiterals name="IN"/>
      <eLiterals name="OUT" value="1"/>
      <eLiterals name="INOUT" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="RoutineResultTable" eSuperTypes="#//tables/Table"/>
    <eClassifiers xsi:type="ecore:EClass" name="Method" eSuperTypes="#//routines/Function">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Method is a specialization of Function to indicate the function was created in support of the user-defined type (UDT). &#xD;&#xA;&#xD;&#xA;From 5WD-02-Foundation-2002-12 &#xD;&#xA;4.23 SQL-invoked routines &#xD;&#xA;&#xD;&#xA;- If the SQL-invoked routine is an SQL-invoked method, then an indication of the user-defined type whose descriptor contains the corresponding method specification descriptor"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="overriding" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="constructor" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="UserDefinedFunction" eSuperTypes="#//routines/Function">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="The User-Defined Fuction (UDF) is a specialization of Function to indicate the function was created by the user or the database, but one that was not created in support of the user-defined type (UDT). The function created by a UDT is a is another class, Method, in this class diagram"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BuiltInFunction" eSuperTypes="#//routines/Function"/>
  </eSubpackages>
  <eSubpackages name="statements" nsURI="http:///org/eclipse/datatools/modelbase/sql/statements.ecore"
      nsPrefix="SQLStatements">
    <eClassifiers xsi:type="ecore:EClass" name="SQLStatement" abstract="true" interface="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A single statement of the following types (from section 13.5):&#xD;&#xA;&lt;SQL executable statement> ::=&#xD;&#xA;    &lt;SQL control statement>&#xD;&#xA;  | &lt;SQL data statement>&#xD;&#xA;  | &lt;SQL schema statement>&#xD;&#xA;  | &lt;SQL transaction statement>&#xD;&#xA;  | &lt;SQL connection statement>&#xD;&#xA;  | &lt;SQL session statement>&#xD;&#xA;  | &lt;SQL diagnostics statement>&#xD;&#xA;  | &lt;SQL dynamic statement>&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="getSQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eOperations name="setSQL">
        <eParameters name="sqlText" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      </eOperations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SQLDataStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLSchemaStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLControlStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLDataChangeStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLDataStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLStatementDefault" eSuperTypes="#//schema/SQLObject #//statements/SQLStatement">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="SQL" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SQLConnectionStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLDiagnosticsStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLDynamicStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLSessionStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
    <eClassifiers xsi:type="ecore:EClass" name="SQLTransactionStatement" abstract="true"
        interface="true" eSuperTypes="#//statements/SQLStatement"/>
  </eSubpackages>
  <eSubpackages name="tables" nsURI="http:///org/eclipse/datatools/modelbase/sql/tables.ecore"
      nsPrefix="SQLTables">
    <eClassifiers xsi:type="ecore:EClass" name="ViewTable" eSuperTypes="#//tables/DerivedTable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;&#xD;&#xA;A derived table is a table derived directly or indirectly from one or more other tables by the evaluation of a &lt;query expression> whose result has an element type that is a row type. The values of a derived table are derived from the values of the underlying tables when the &lt;query expression> is evaluated.&#xD;&#xA;&#xD;&#xA;A viewed table is a named derived table defined by a &lt;view definition> . A viewed table is sometimes called a view.&#xD;&#xA;&#xD;&#xA;A view descriptor describes a view. In addition to the components of a derived table descriptor, a view descriptor includes:&#xD;&#xA; - The name of the view.&#xD;&#xA; - An indication of whether the view has the CHECK OPTION ; if so, whether it is to be applied as CASCADED or LOCAL.&#xD;&#xA; - The original &lt;query expression> of the view.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="checkType" eType="#//tables/CheckType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TemporaryTable" eSuperTypes="#//tables/BaseTable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="local" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="deleteOnCommit" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Table" abstract="true" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. A row is a value of a row type. Every row of the same table has the same row type. The value of the i-th field of every row in a table is the value of the i-th column of that row in the table. The row is the smallest unit of data that can be inserted into a table and deleted from a table.&#xD;&#xA;&#xD;&#xA;The degree of a table, and the degree of each of its rows, is the number of columns of that table. The number of rows in a table is its cardinality. A table whose cardinality is 0 (zero) is said to be empty.&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;&#xD;&#xA;A table is described by a table descriptor. A table descriptor is either a base table descriptor, a view descriptor, or a derived table descriptor (for a derived table that is not a view).&#xD;&#xA;Every table descriptor includes:&#xD;&#xA; - The column descriptor of each column in the table.&#xD;&#xA; - The name, if any, of the structured type, if any, associated with the table.&#xD;&#xA; - An indication of whether the table is insertable-into or not.&#xD;&#xA; - An indication of whether the table is a referenceable table or not, and an indication of whether the selfreferencing column is a system-generated, a user-generated, or a derived self-referencing column.&#xD;&#xA; - A list, possibly empty, of the names of its direct supertables.&#xD;&#xA; - A list, possibly empty, of the names of its direct subtables.&#xD;&#xA;&#xD;&#xA;A base table descriptor describes a base table. In addition to the components of every table descriptor, a base table descriptor includes:&#xD;&#xA; - The name of the base table.&#xD;&#xA; - An indication of whether the table is a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA; - If the base table is a global temporary table, a created local temporary table, or a declared local temporary table, then an indication of whether ON COMMIT PRESERVE ROWS was specified or ON COMMIT DELETE ROWS was specified or implied.&#xD;&#xA; - The descriptor of each table constraint specified for the table.&#xD;&#xA; - A non-empty set of functional dependencies, according to the rules given in Subclause 4.18, &quot;Functional dependencies&quot;.&#xD;&#xA; - A non-empty set of candidate keys, according to the rules of Subclause 4.19, &quot;Candidate keys&quot;.&#xD;&#xA; - A preferred candidate key, which may or may not be additionally designated the primary key, according to the Rules in Subclause 4.18, &quot;Functional dependencies&quot;.&#xD;&#xA;&#xD;&#xA;4.14.2 Referenceable tables, subtables, and supertables&#xD;&#xA;&#xD;&#xA;A table RT whose row type is derived from a structured type ST is called a typed table. Only a base table or a view can be a typed table. A typed table has columns corresponding, in name and declared type, to every attribute of ST and one other column REFC that is the self-referencing column of RT; let REFCN be the &lt;column name> of REFC. The declared type of REFC is necessarily REF (ST) and the nullability characteristic of REFC is known not nullable. If RT is a base table, then the table constraint &quot;UNIQUE (REFCN)&quot; is implicit in the definition of RT. A typed table is called a referenceable table. A self-referencing column cannot be updated.&#xD;&#xA;&#xD;&#xA;Its value is determined during the insertion of a row into the referenceable table. The value of a system-generated self-referencing column and a derived self-referencing column is automatically generated when the row is inserted into the referenceable table. The value of a user-generated self-referencing column is supplied as part of the candidate row to be inserted into the referenceable table.&#xD;&#xA;&#xD;&#xA;A table Ta is a direct subtable of another table Tb if and only if the &lt;table name> of Tb is contained in the &lt;subtable clause> contained in the &lt;table definition> or &lt;view definition> of Ta. Both Ta and Tb shall be created on a structured type and the structured type of Ta shall be a direct subtype of the structured type of Tb.&#xD;&#xA;&#xD;&#xA;A table Ta is a subtable of a table Tb if and only if any of the following are true:&#xD;&#xA;1) Ta and Tb are the same named table.&#xD;&#xA;2) Ta is a direct subtable of Tb.&#xD;&#xA;3) There is a table Tc such that Ta is a direct subtable of Tc and Tc is a subtable of Tb.&#xD;&#xA;A table T is considered to be one of its own subtables. Subtables of T other than T itself are called its proper subtables. A table shall not have itself as a proper subtable.&#xD;&#xA;&#xD;&#xA;A table Tb is called a supertable of a table Ta if Ta is a subtable of Tb. If Ta is a direct subtable of Tb, then Tb is called a direct supertable of Ta. A table that is not a subtable of any other table is called a maximal supertable. Let Ta be a maximal supertable and T be a subtable of Ta. The set of all subtables of Ta (which includes Ta itself) is called the subtable family of T or (equivalently) of Ta. Every subtable family has exactly one maximal supertable. A leaf table is a table that does not have any proper subtables.&#xD;&#xA;&#xD;&#xA;Those columns of a subtable Ta of a structured type STa that correspond to the inherited attributes of STa are&#xD;&#xA;called inherited columns. Those columns of Ta that correspond to the originally-defined attributes of STa are&#xD;&#xA;called originally-defined columns.&#xD;&#xA;&#xD;&#xA;Let TB be a subtable of TA. Let SLA be the &lt;value expression> sequence implied by the &lt;select list> &quot;*&quot; in the&#xD;&#xA;&lt;query specification> &quot;SELECT * FROM TA&quot;. For every row RB in the value of TB there exists exactly one&#xD;&#xA;row RA in the value of TA such that RA is the result of the &lt;row subquery> &quot;SELECT SLA FROM VALUES&#xD;&#xA;RRB&quot;, where RRB is some &lt;row value constructor> whose value is RB. RA is said to be the superrow in TA of&#xD;&#xA;RB and RB is said to be the subrow in TB of RA. If TA is a base table, then the one-to-one correspondence&#xD;&#xA;between superrows and subrows is guaranteed by the requirement for a unique constraint to be specified for&#xD;&#xA;some supertable of TA. If TA is a view, then such one-to-one correspondence is guaranteed by the requirement&#xD;&#xA;for a unique constraint to be specified on the leaf generally underlying table of TA.&#xD;&#xA;Users shall have the UNDER privilege on a table before they can use the table in a subtable definition. A table&#xD;&#xA;can have more than one proper subtable. Similarly, a table can have more than one proper supertable.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="columns" lowerBound="1"
          upperBound="-1" eType="#//tables/Column" containment="true" eOpposite="#//tables/Column/table"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="supertable" eType="#//tables/Table"
          eOpposite="#//tables/Table/subtables"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="subtables" upperBound="-1"
          eType="#//tables/Table" eOpposite="#//tables/Table/supertable"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/tables"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="udt" eType="#//datatypes/StructuredUserDefinedType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="triggers" upperBound="-1"
          eType="#//tables/Trigger" eOpposite="#//tables/Trigger/subjectTable"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="index" upperBound="-1"
          eType="#//constraints/Index" eOpposite="#//constraints/Index/table"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="selfRefColumnGeneration"
          eType="#//tables/ReferenceType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="insertable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          changeable="false" volatile="true" transient="true" derived="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="updatable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          changeable="false" volatile="true" transient="true" derived="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PersistentTable" eSuperTypes="#//tables/BaseTable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table.&#xD;&#xA;&#xD;&#xA;A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DerivedTable" abstract="true" eSuperTypes="#//tables/Table">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;&#xD;&#xA;A derived table is a table derived directly or indirectly from one or more other tables by the evaluation of a &lt;query expression> whose result has an element type that is a row type. The values of a derived table are derived from the values of the underlying tables when the &lt;query expression> is evaluated.&#xD;&#xA;&#xD;&#xA;A derived table descriptor describes a derived table. In addition to the components of every table descriptor, a derived table descriptor includes:&#xD;&#xA; - The &lt;query expression> that defines how the table is to be derived.&#xD;&#xA; - An indication of whether the derived table is updatable or not.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="queryExpression" eType="#//expressions/QueryExpression"
          containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BaseTable" abstract="true" eSuperTypes="#//tables/Table">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA;&#xD;&#xA;All base tables are updatable. Every column of a base table is an updatable column. Derived tables and transient tables are either updatable or not updatable. The operations of update and delete are permitted for updatable tables, subject to constraining Access Rules. Some updatable tables, including all base tables whose row type is not derived from a user-defined type that is not instantiable, are also insertable-into, in which case the operation of insert is also permitted, again subject to Access Rules.&#xD;&#xA;&#xD;&#xA;A base table descriptor describes a base table. In addition to the components of every table descriptor, a base table descriptor includes:&#xD;&#xA; - The name of the base table.&#xD;&#xA; - An indication of whether the table is a persistent base table, a global temporary table, a created local temporary table, or a declared local temporary table.&#xD;&#xA; - If the base table is a global temporary table, a created local temporary table, or a declared local temporary table, then an indication of whether ON COMMIT PRESERVE ROWS was specified or ON COMMIT DELETE ROWS was specified or implied.&#xD;&#xA; - The descriptor of each table constraint specified for the table.&#xD;&#xA; - A non-empty set of functional dependencies, according to the rules given in Subclause 4.18, &quot;Functional dependencies&quot;.&#xD;&#xA; - A non-empty set of candidate keys, according to the rules of Subclause 4.19, &quot;Candidate keys&quot;.&#xD;&#xA; - A preferred candidate key, which may or may not be additionally designated the primary key, according to the Rules in Subclause 4.18, &quot;Functional dependencies&quot;.&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="getUniqueConstraints" eType="#//schema/List"/>
      <eOperations name="getForeignKeys" eType="#//schema/List"/>
      <eOperations name="getPrimaryKey" eType="#//constraints/PrimaryKey"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constraints" upperBound="-1"
          eType="#//constraints/TableConstraint" containment="true" eOpposite="#//constraints/TableConstraint/BaseTable"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="referencingForeignKeys"
          upperBound="-1" eType="#//constraints/ForeignKey" eOpposite="#//constraints/ForeignKey/referencedTable"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="CheckType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.14 Tables&#xD;&#xA;&#xD;&#xA;A table is a collection of rows having one or more columns. [...]&#xD;&#xA;&#xD;&#xA;A view descriptor describes a view. In addition to the components of a derived table descriptor, a view descriptor includes:&#xD;&#xA; - The name of the view.&#xD;&#xA; - An indication of whether the view has the CHECK OPTION ; if so, whether it is to be applied as CASCADED or LOCAL.&#xD;&#xA; - The original &lt;query expression> of the view.&#xD;&#xA;"/>
      </eAnnotations>
      <eLiterals name="CASCADED"/>
      <eLiterals name="LOCAL" value="1"/>
      <eLiterals name="NONE" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ReferenceType">
      <eLiterals name="SYSTEM_GENERATED"/>
      <eLiterals name="USER_GENERATED" value="1"/>
      <eLiterals name="DERIVED_SELF_REF" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Column" eSuperTypes="#//schema/TypedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="4.13 Columns, fields, and attributes&#xD;&#xA;&#xD;&#xA;The terms column, field, and attribute refer to structural components of tables, row types, and structured types, respectively, in analogous fashion. As the structure of a table consists of one or more columns, so does the structure of a row type consist of one or more fields and that of a structured type one or more attributes. Every structural element, whether a column, a field, or an attribute, is primarily a name paired with a declared type.&#xD;&#xA;&#xD;&#xA;The elements of a structure are ordered. Elements in different positions in the same structure can have the same declared type but not the same name. Although the elements of a structure are distinguished from each other by name, in some circumstances the compatibility of two structures (for the purpose at hand) is determined solely by considering the declared types of each pair of elements at the same ordinal position.&#xD;&#xA;&#xD;&#xA;A table (see Subclause 4.14, &quot;Tables&quot;) is defined on one or more columns and consists of zero or more rows. A column has a name and a declared type. Each row in a table has exactly one value for each column. Each value in a row is a value in the declared type of the column.&#xD;&#xA;NOTE 21: The declared type includes the null value and values in proper subtypes of the declared type. Every column has a nullability characteristic that indicates whether the value from that column can be the null value. The possible values of nullability characteristic are known not nullable and possibly nullable.&#xD;&#xA;&#xD;&#xA;A column C is described by a column descriptor. A column descriptor includes:&#xD;&#xA; - The name of the column.&#xD;&#xA; - Whether the name of the column is an implementation-dependent name.&#xD;&#xA; - If the column is based on a domain, then the name of that domain; otherwise, the data type descriptor of the declared type of C.&#xD;&#xA; - The value of &lt;default option> , if any, of C.&#xD;&#xA; - The nullability characteristic of C.&#xD;&#xA; - The ordinal position of C within the table that contains it.&#xD;&#xA; - An indication of whether C is a self-referencing column of a base table or not.&#xD;&#xA; - If the declared type of C is a reference type, then an indication of whether references are to be checked, and the &lt;reference scope check action> , if specified or implied.&#xD;&#xA; - An indication of whether C is an identity column or not.&#xD;&#xA; - If C is an identity column, then an indication of whether values are always generated or generated by default.&#xD;&#xA; - If C is an identity column, then the start value of C.&#xD;&#xA; - If C is an identity column, then the descriptor of the internal sequence generator for C.&#xD;&#xA;NOTE 22 - Identity columns and the meaning of &quot;start value&quot; are described in Subclause 4.14.4, &quot;Identity columns&quot;.&#xD;&#xA;&#xD;&#xA; - If C is a generated column, then the generation expression of C.&#xD;&#xA;NOTE 23 - Generated columns and the meaning of &quot;generation expression&quot; are described in Subclause 4.14.5, &quot;Base columns and generated columns&quot;.&#xD;&#xA;&#xD;&#xA;An attribute A is described by an attribute descriptor. An attribute descriptor includes:&#xD;&#xA; - The name of the attribute.&#xD;&#xA; - The data type descriptor of the declared type of A.&#xD;&#xA; - The ordinal position of A within the structured type that contains it.&#xD;&#xA; - The value of the implicit or explicit &lt;attribute default> of A.&#xD;&#xA; - If the data type of the attribute is a reference type, then an indication of whether reference values shall be checked, and the &lt;reference scope check action> , if specified or implied.&#xD;&#xA; - The name of the structured type defined by the &lt;user-defined type definition> that defines A.&#xD;&#xA;&#xD;&#xA;A field F is described by a field descriptor. A field descriptor includes:&#xD;&#xA; - The name of the field.&#xD;&#xA; - The data type descriptor of the declared type of F.&#xD;&#xA; - The ordinal position of F within the row type that simply contains it.&#xD;&#xA; - If the data type of the field is a reference type, then an indication of whether reference values shall be checked, and the &lt;reference scope check action> , if specified or implied.&#xD;&#xA;"/>
      </eAnnotations>
      <eOperations name="isPartOfForeignKey" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eOperations name="isPartOfUniqueConstraint" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eOperations name="isPartOfPrimaryKey" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="table" lowerBound="1"
          eType="#//tables/Table" transient="true" eOpposite="#//tables/Table/columns"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="identitySpecifier" eType="#//schema/IdentitySpecifier"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="generateExpression" eType="#//expressions/ValueExpression"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="implementationDependent"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="False"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="nullable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="True"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="defaultValue" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeCheck" eType="#//schema/ReferentialActionType"
          defaultValueLiteral="NO_ACTION"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="scopeChecked" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Trigger" eSuperTypes="#//schema/SQLObject">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Section 4.38:&#xD;&#xA;&#xD;&#xA;A trigger is defined by a &lt;trigger definition> . A &lt;trigger definition> specifies a trigger that is described by a&#xD;&#xA;trigger descriptor . A trigger descriptor includes:&#xD;&#xA;  - The name of the trigger.&#xD;&#xA;  - The name of the base table that is the subject table.&#xD;&#xA;  - The trigger action time (BEFORE or AFTER ).&#xD;&#xA;  - The trigger event (INSERT , DELETE , or UPDATE ).&#xD;&#xA;  - Whether the trigger is a statement-level trigger or a row-level trigger.&#xD;&#xA;  - Any old transition variable name, new transition variable name, old transition table name, new transition table name.&#xD;&#xA;  - The triggered action.&#xD;&#xA;  - The trigger column list (possibly empty) for the trigger event.&#xD;&#xA;  - The triggered action column set of the triggered action.&#xD;&#xA;  - The timestamp of creation of the trigger.&#xD;&#xA;&#xD;&#xA;The order of execution of a set of triggers is ascending by value of their timestamp of creation in their descriptors, such that the oldest trigger executes first. If one or more triggers have the same timestamp value, then their relative order of execution is implementation-defined.&#xD;&#xA;&#xD;&#xA;A schema might include one or more trigger descriptors, each of which includes the definition of a triggered action specifying a &lt;triggered SQL statement> that is to be executed (either once for each affected row, in the case of a row-level trigger, or once for the whole triggering INSERT , DELETE , MERGE , or UPDATE statement, in the case of a statement-level trigger) before or after rows are inserted into a table, rows are deleted from a table, or one or more columns are updated in rows of a table. The execution of such a triggered action resulting from the insertion, deletion, or updating of a table may cause the triggering of further triggered actions.&#xD;&#xA;&#xD;&#xA;The &lt;triggered SQL statement> of a triggered action is effectively executed either immediately before or&#xD;&#xA;immediately after the trigger event, as determined by the specified trigger action time.&#xD;&#xA;&#xD;&#xA;Format of trigger definition and syntax rules are defined in section 11.39.&#xD;&#xA;&#xD;&#xA;OCL rules are derived from these syntax rules:&#xD;&#xA;4) The schema identified by the explicit or implicit &lt;schema name> of a &lt;trigger name> TRN shall not include a trigger descriptor whose trigger name is TRN.&#xD;&#xA;5) T shall be a base table that is not a declared local temporary table.&#xD;&#xA;6) If a &lt;trigger column list> is specified, then:&#xD;&#xA;  a) No &lt;column name> shall appear more than once in the &lt;trigger column list> .&#xD;&#xA;  b) The &lt;column name> s of the &lt;trigger column list> shall identify columns of T.&#xD;&#xA;9) If OR or NR is specified, then FOR EACH ROW shall be specified.&#xD;&#xA;12) If BEFORE is specified, then:&#xD;&#xA;  b) Neither OLD TABLE nor NEW TABLE shall be specified.&#xD;&#xA;"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="schema" lowerBound="1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/triggers"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="subjectTable" lowerBound="1"
          eType="#//tables/Table" eOpposite="#//tables/Table/triggers"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="actionStatement" lowerBound="1"
          upperBound="-1" eType="#//statements/SQLStatement" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="triggerColumn" upperBound="-1"
          eType="#//tables/Column"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="actionGranularity" eType="#//tables/ActionGranularityType"
          defaultValueLiteral="STATEMENT"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="when" eType="#//expressions/SearchCondition"
          containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="timeStamp" eType="#//schema/Date"
          changeable="false">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Triggers on the same table with the same action time are executed in order of creation, i.e. the time stamp, such that older triggers have priority."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="actionTime" eType="#//tables/ActionTimeType"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="updateType" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="insertType" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="deleteType" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="oldRow" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="newRow" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="oldTable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="newTable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ActionTimeType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="The literals of this enumeration are used to indicate whether the actionStatement of Trigger are executed before or after rows are inserted into a table, rows are deleted from a table, or one or more columns are updated in rows of a table."/>
      </eAnnotations>
      <eLiterals name="AFTER"/>
      <eLiterals name="BEFORE" value="1"/>
      <eLiterals name="INSTEADOF" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ActionGranularityType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="The literals of this enumeration are used to indicate whether the actionStatement of a Trigger is to be executed once for each affected row, in the case of a row-level trigger, or once for the whole triggering INSERT , DELETE , MERGE , or UPDATE&#xD;&#xA;statement, in the case of a statement-level trigger.&#xD;&#xA;"/>
      </eAnnotations>
      <eLiterals name="STATEMENT"/>
      <eLiterals name="ROW" value="1"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="accesscontrol" nsURI="http:///org/eclipse/datatools/modelbase/sql/accesscontrol.ecore"
      nsPrefix="SQLAccessControl">
    <eClassifiers xsi:type="ecore:EClass" name="AuthorizationIdentifier" abstract="true"
        eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedSchema" upperBound="-1"
          eType="#//schema/Schema" eOpposite="#//schema/Schema/owner"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="receivedRoleAuthorization"
          upperBound="-1" eType="#//accesscontrol/RoleAuthorization" eOpposite="#//accesscontrol/RoleAuthorization/grantee"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="grantedRoleAuthorization"
          upperBound="-1" eType="#//accesscontrol/RoleAuthorization" eOpposite="#//accesscontrol/RoleAuthorization/grantor"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="grantedPrivilege" upperBound="-1"
          eType="#//accesscontrol/Privilege" eOpposite="#//accesscontrol/Privilege/grantor"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="receivedPrivilege" upperBound="-1"
          eType="#//accesscontrol/Privilege" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Privilege" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="grantable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="action" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="grantor" lowerBound="1"
          eType="#//accesscontrol/AuthorizationIdentifier" eOpposite="#//accesscontrol/AuthorizationIdentifier/grantedPrivilege"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="object" lowerBound="1"
          eType="#//schema/SQLObject"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Group" eSuperTypes="#//accesscontrol/AuthorizationIdentifier">
      <eStructuralFeatures xsi:type="ecore:EReference" name="user" upperBound="-1"
          eType="#//accesscontrol/User" derived="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="User" eSuperTypes="#//accesscontrol/AuthorizationIdentifier"/>
    <eClassifiers xsi:type="ecore:EClass" name="Role" eSuperTypes="#//accesscontrol/AuthorizationIdentifier">
      <eStructuralFeatures xsi:type="ecore:EReference" name="roleAuthorization" lowerBound="1"
          upperBound="-1" eType="#//accesscontrol/RoleAuthorization" eOpposite="#//accesscontrol/RoleAuthorization/role"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="RoleAuthorization" eSuperTypes="#//schema/SQLObject">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="grantable" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="role" lowerBound="1"
          eType="#//accesscontrol/Role" eOpposite="#//accesscontrol/Role/roleAuthorization"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="grantee" lowerBound="1"
          eType="#//accesscontrol/AuthorizationIdentifier" eOpposite="#//accesscontrol/AuthorizationIdentifier/receivedRoleAuthorization"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="grantor" lowerBound="1"
          eType="#//accesscontrol/AuthorizationIdentifier" eOpposite="#//accesscontrol/AuthorizationIdentifier/grantedRoleAuthorization"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TablePrivilege" eSuperTypes="#//accesscontrol/Privilege">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="withHierarchy" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="DoubleObjectPrivilege" eSuperTypes="#//accesscontrol/Privilege">
      <eStructuralFeatures xsi:type="ecore:EReference" name="object2" lowerBound="1"
          eType="#//schema/SQLObject"/>
    </eClassifiers>
  </eSubpackages>
</ecore:EPackage>
