CR01, context: Message, definition: self.receiveEvent.asType(<InteractionFragment>).covered->forAll(r|r.represents.type.isTypeOf(<Class>) implies r.represents.type.asType(<Class>).ownedOperation->exists(op| op.name=self.name))
CR02, context: Association, definition: self.memberEnd.size() > 0 implies self.memberEnd->forAll(p | p.type <> null implies p.type.namespace = self.namespace)
CR03, context: Association, definition: self.memberEnd->forAll(p1,p2 : <Property>| p1 <> p2 implies p1.name <> p2.name)
CR04, context: Association, definition: self.memberEnd->size() > 0 implies self.memberEnd->select(p | p.aggregation.name = 'composite')->size() <= 1 or self.memberEnd->select(m | m.aggregation.name = 'shared')->size() <= 1
CR05, context: Class, definition: self.ownedAttribute->forAll(p1,p2:<Property> | p1 <> p2 implies p1.name <> p2.name)
CR06, context: Property, definition: (self.association <> null and self.aggregation.name='composite') implies (self.upper >= 0 and self.upper <= 1)
CR07, context: Package, definition: self.packagedElement->forAll(e1,e2:<PackageableElement> | (e1 <> e2) and (e1.name <> '' and e2.name <> '') implies (e1.name <> e2.name))
CR08, context: Interface, definition: self.ownedAttribute->forAll(pr: <Property>| pr.association <> null or pr.visibility.name = 'public') and self.ownedOperation->forAll(o:<Operation>| o.visibility.name = 'public')
CR09, context: Class, definition: self.ownedOperation->forAll( o1,o2 : <Operation> | o1 <> o2 implies (o1.name <> o2.name or o1.ownedParameter->size() <> o2.ownedParameter->size() or o1.ownedParameter->exists(t1:<Type> | o2.ownedParameter->excludes(t1)) or o2.ownedParameter->exists(t2:<Type> | o1.ownedParameter->excludes(t2))))
CR10, context: Operation, definition: self.ownedParameter->forAll(p1,p2:<Parameter>| p1 <> p2 implies p1.name <> p2.name)
CR11, context: Operation, definition: self.ownedParameter->forAll(p:<Parameter>|p.type <> null and self.owner.isTypeOf(<Class>) implies (p.type.namespace = self.owner.asType(<Class>).namespace))
CR12, context: Generalization, definition: self.source->forAll(e1: <Element> | e1.isKindOf(<NamedElement>) implies self.target->forAll(e2 : <Element> | e2.isKindOf(<NamedElement>) and e1.asType(<NamedElement>).namespace = e2.asType(<NamedElement> ).namespace))
CR13, context: Transition, definition: let classifier : <BehavioredClassifier> = self.owner.asType(<Region>).stateMachine.context in (self.owner.asType(<Region>).stateMachine <> null implies classifier.isTypeOf(<Class>) implies classifier.asType(<Class>).ownedOperation->exists(o:<Operation> | o.name = self.name))
CR14, context: Operation, definition: self.ownedParameter->select(p : <Parameter> | p.direction.name = 'return')->size() <= 1
CR15, context: Lifeline, definition: self.represents.type.isTypeOf(<Class>)
CR16, context: Message, definition: self.receiveEvent.asType(<InteractionFragment>).covered->forAll(r|r.represents.type.isTypeOf(<Class>) implies r.represents.type.asType(<Class>).ownedBehavior->exists(ob| ob.asType(<StateMachine>).region->exists(re|re.asType(<Region>).transition->exists(t|t.name=self.name))))
CR17, context: Lifeline, definition: self.coveredBy->asList().size() > 0 implies self.coveredBy->asList()->first().asType(<InteractionFragment>).covered->isEmpty()
CR18, context: Operation, definition: allInstances(<Action>)->exists(a1: <Action>|  allInstances(<Message>)->exists(m1: <Message>| (a1.name = self.name) and (m1.name = self.name) implies a1.name = m1.name))
CR19, context: Message, definition: allInstances(<Operation>)->forAll(op:<Operation>| self.name = op.name implies not op.isAbstract)
CR20, context: Message, definition: allInstances(<Operation>)->forAll(op:<Operation>| op.name = self.name implies ((self.visibility.name = 'public') and (op.visibility.name = 'public')) or ((self.visibility.name = 'private') and (op.visibility.name = 'private')) or ((self.visibility.name = 'protected') and (op.visibility.name = 'protected')))
CR21, context: Class, definition: allInstances(<Activity>)->exists(at:<Activity>|self.name = at.name)
CR22, context: UseCase, definition: allInstances(<Class>)->exists(ct:<Class>| ct.name = self.name)
CR23, context: InteractionFragment, definition: allInstances(<Class>)->exists(ct:<Class>| ct.name = self.name)
CR24, context: InteractionFragment, definition: allInstances(<UseCase>)->exists(ut:<UseCase>| ut.name = self.name)
CR25, context: CreateLinkObjectAction, definition: allInstances(<Association>)->forAll(at:<Association>|  at.name = self.name implies self.result = at)
CR26, context: Class, definition: self.isAbstract = true implies  self.ownedOperation->forAll(o:<Operation>| o.isAbstract)
CR27, context: Lifeline, definition: allInstances(<Interface>)->forAll(it:<Interface>| self <> it implies allInstances(<Class>)->select(ct:<Class>| ct.isAbstract)->forAll(ab:<Class>| ab <> self.represents.type))
